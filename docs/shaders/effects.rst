.. _shader-effects:

Effect Definition Spec
======================

An "Effect" is a self-contained unit that transforms inputs to outputs using one or more rendering or compute passes.

1. Schema
---------

The Effect Definition is a JavaScript class (or a JSON object that resolves to one) that adheres to the following schema.

.. code-block:: javascript

   import { Effect } from 'noisemaker/shader-effects';

   export default class SimpleBloom extends Effect {
     name = "SimpleBloom";
     namespace = "examples";
     func = "bloom";

     globals = {
       intensity: {
         type: "float",
         default: 0.5,
         min: 0,
         max: 1,
         ui: { label: "Intensity", control: "slider" }
       },
       threshold: {
         type: "float",
         default: 0.5,
         min: 0,
         max: 1,
         ui: { label: "Threshold", control: "slider" }
       }
     };

     textures = {
       downsampled: { width: "25%", height: "25%", format: "rgba16f" }
     };

     passes = [
       {
         name: "downsample",
         type: "render",
         program: "downsample",
         inputs: {
           scene: "inputTex"
         },
         outputs: {
           color: "downsampled"
         }
       },
       {
         name: "composite",
         type: "render",
         program: "composite",
         inputs: {
           scene: "inputTex",
           bloom: "downsampled"
         },
         outputs: {
           color: "outputColor"
         }
       }
     ];
   }

2. Key Concepts
---------------


* ``namespace``: Logical grouping for the effect (e.g., ``"nd"``, ``"basics"``). Combined with ``name``, it forms the unique identity.
* ``textures``: Defines the internal render targets. Dimensions can be absolute, relative to screen (``"screen"``, ``"50%"``), or fixed.
* ``passes``:

  * ``type``: ``render`` (fragment shader) or ``compute`` (compute shader).
  * ``program``: Key to look up the shader code (GLSL/WGSL).
  * ``inputs``: Maps shader uniform samplers to texture names.
  * ``outputs``: Maps shader output locations (or write buffers) to texture names.
  * ``iterations``: Number of times to run this pass.
  * ``pingpong``: Array of two texture names to swap input/output roles during iterations.

3. On-Disk Layout
-----------------

Effects are typically authored as a directory containing a definition file, shader sources, and documentation.

.. code-block:: text

   my-effect/
   ├── definition.js       # Exports the Effect Class
   ├── glsl/
   │   └── my-shader.glsl  # WebGL implementation
   ├── wgsl/
   │   └── my-shader.wgsl  # WebGPU implementation
   └── help.md             # User documentation (markdown)

**Shader References:**
The ``program`` field in a pass can specify a relative path (e.g., ``"./my-shader"``). The runtime resolves this path relative to the definition file, injecting the backend-specific directory (``glsl/`` or ``wgsl/``) and appending the appropriate extension (``.glsl`` or ``.wgsl``).

**Documentation:**
The ``help.md`` file is optional but recommended for library effects. It provides context for the editor UI.

**Example DSL:**
Example DSL snippets are auto-generated by the demo UI based on the effect type (starter, filter, or mixer). There is no need to maintain ``example.dsl`` files manually.

4. Global Enums
---------------

To promote consistency and reduce duplication, common enumerations are defined in a global registry. Effects reference these enums by name instead of redefining the choices.

**Global Registry Example:**

.. code-block:: javascript

   const globalEnums = {
     "interpolation": {
       "nearest": 0,
       "linear": 1,
       "hermite": 2,
       "cubic": 3
     },
     "wrapMode": {
       "clamp": 0,
       "repeat": 1,
       "mirror": 2
     }
   };

**Effect Usage:**

.. code-block:: javascript

   globals: {
     interp: {
       type: "int",
       enum: "interpolation", // References global key
       default: "linear"      // Uses string key
     }
   }

The runtime resolves the string value (e.g., ``"linear"``) to its integer counterpart (``1``) before binding to the shader.

5. Lifecycle Methods
--------------------

For effects requiring CPU-side state management (e.g., simulation steps, complex time-keeping, or audio analysis), the Effect Class implements lifecycle methods.

**Method Contract:**
The runtime invokes these methods at specific stages. This allows for stateful logic that persists across frames.

.. code-block:: javascript

   // Inside the Effect Class

   // Called once when the effect is loaded.
   onInit() {
     this.state.generation = 0;
     this.state.lastUpdate = 0;
   }

   // Called every frame before rendering.
   // Use this to update state and compute dynamic uniforms.
   onUpdate({ time, delta, uniforms }) {
     // Example: Update generation only every 100ms
     if (time - this.state.lastUpdate > 0.1) {
       this.state.generation++;
       this.state.lastUpdate = time;
     }

     // Return an object to override or inject uniform values for this frame
     return {
       u_generation: this.state.generation,
       u_computed_value: Math.sin(time) * uniforms.intensity
     };
   }

   // Called when the effect is removed/destroyed.
   onDestroy() {
     // Cleanup resources (e.g., event listeners, audio contexts)
   }

**Note:** While the declarative pipeline handles rendering loops and ping-ponging, these methods are essential for logic that cannot be expressed purely in shaders or static graphs.

6. Effect Class
---------------

To support complex effects and promote code reuse, the pipeline provides a single base class: ``Effect``. **The Class IS the Definition.**

The JSON schema (Section 1) is the declarative data aspect of the definition, while the Class is the runtime embodiment. When ``hooks.js`` exports a default class extending ``Effect``, the runtime uses it as the definition.

6.1 The ``Effect`` Base Class
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The ``Effect`` class provides the foundation for all effects, from simple single-pass filters to complex multi-pass simulations.

**Features:**


* **Automatic Uniform Management:** Automatically maps ``globals`` defined in the JSON to internal state.
* **Lifecycle Methods:** Provides ``onInit``, ``onUpdate``, and ``onDestroy`` methods.
* **Buffer Management:** Helpers for managing custom storage buffers or textures that persist across frames.
* **Ping-Pong Helpers:** Utilities for managing double-buffered state (read/write swapping) beyond the declarative ``pingpong`` property.
* **Dynamic Dispatch:** Methods to influence the execution of passes dynamically (e.g., skipping passes based on state).
* **Helper Utilities:** Access to common utilities via ``this.context``.

**Example:**

.. code-block:: javascript

   import { Effect } from 'noisemaker/shader-effects';

   export default class PulseEffect extends Effect {
     onInit() {
       this.state.phase = 0;
     }

     onUpdate({ time, delta, uniforms }) {
       // Update internal state
       this.state.phase += delta * uniforms.speed;

       // Return computed uniforms to be bound to the shader
       return {
         u_pulse: Math.sin(this.state.phase) * uniforms.intensity
       };
     }
   }

**Complex Example:**

.. code-block:: javascript

   import { Effect } from 'noisemaker/shader-effects';

   export default class WormsEffect extends Effect {
     onInit() {
       // Initialize custom simulation state
       this.agents = new Float32Array(1000 * 4);
       this.initAgents();
     }

     onUpdate({ time }) {
       // Perform CPU-side simulation steps if needed
       this.updateAgents(time);

       // Return uniforms, including binding custom buffers if supported
       return {
         u_agent_count: 1000,
         u_time: time
       };
     }
   }

7. Formal JSON Schema (Informative)
-----------------------------------

The following normative shape defines an ``EffectDefinition``. Validation MUST apply before graph compilation. Regular expressions shown in ``/.../`` form.

.. code-block:: javascript

   // Pseudocode JSON Schema (non exhaustive formatting for brevity)
   {
     "$id": "noisemaker.shader-effect.v1",
     "type": "object",
     "required": ["name", "passes"],
     "properties": {
       "name": { "type": "string", "pattern": "^[A-Za-z0-9_\-]{1,64}$" },
       "namespace": { "type": "string", "pattern": "^[a-z0-9]+$", "default": "basics" },
       "version": { "type": "string", "pattern": "^\d+\.\d+\.\d+$", "default": "1.0.0" },
       "globals": { "type": "object", "additionalProperties": { "$ref": "#/definitions/uniformSpec" } },
       "textures": { "type": "object", "additionalProperties": { "$ref": "#/definitions/textureSpec" } },
       "passes": { "type": "array", "minItems": 1, "items": { "$ref": "#/definitions/passSpec" } },
       "meta": { "type": "object" }
     },
     "definitions": {
       "uniformSpec": {
         "type": "object",
         "required": ["type"],
         "properties": {
           "type": { "type": "string", "enum": ["float","int","uint","bool","vec2","vec3","vec4","mat3","mat4"] },
           "default": { "description": "Optional. Fallback: 0, false, or identity matrix." },
           "min": { "type": "number" },
           "max": { "type": "number" },
           "step": { "type": "number" },
           "choices": {
             "type": "object",
             "additionalProperties": { "type": "integer" },
             "description": "Map of label strings to integer values for dropdowns"
           },
           "enum": { "type": "string", "description": "Reference to a global enum key" },
           "ui": {
             "type": "object",
             "properties": {
               "label": { "type": "string" },
               "control": { "type": "string", "enum": ["slider", "dropdown", "color", "checkbox"] }
             }
           },
           "requires": {
             "type": "object",
             "description": "Conditional visibility logic (e.g. show this uniform only if another uniform has a specific value)"
           }
         }
       },
       "dimensionSpec": {
         "oneOf": [
           {"type": "number", "minimum": 1},
           {"type": "string", "enum": ["screen","auto"]},
           {"type": "string", "pattern": "^(?:100|[1-9]?[0-9])%$"},
           {"type": "object", "required": ["scale"], "properties": {"scale": {"type":"number"}, "clamp": {"type":"object", "properties": {"min": {"type":"number"}, "max": {"type":"number"}}}}}
         ]
       },
       "textureSpec": {
         "type": "object",
         "properties": {
           "width": { "$ref": "#/definitions/dimensionSpec" },
           "height": { "$ref": "#/definitions/dimensionSpec" },
           "format": { "type": "string" },
           "usage": { "type": "array", "items": {"type":"string", "enum":["sample","storage","render","copySrc","copyDst"]} },
           "clear": { "type": "array", "minItems": 4, "maxItems": 4 },
           "persistent": { "type": "boolean", "default": false }
         },
         "required": ["format"],
         "additionalProperties": false,
         "description": "Implicit textures (inputTex, outputColor) bypass this schema and are synthesized by the runtime."
       },
       "passSpec": {
         "type": "object",
         "required": ["name","program"],
         "properties": {
           "name": { "type": "string", "pattern": "^[A-Za-z0-9_\-]{1,64}$" },
           "type": { "type": "string", "enum": ["render","compute","transfer"], "default": "render" },
           "program": { "type": "string" },
           "inputs": { "type": "object", "additionalProperties": {"type":"string"} },
           "outputs": { "type": "object", "additionalProperties": {"type":"string"} },
           "iterations": { "type": "integer", "minimum": 1, "default": 1 },
           "pingpong": { "type": "array", "items": {"type":"string"}, "minItems": 2, "maxItems": 2 },
           "defines": { "type": "object", "additionalProperties": {"type":["string","number","boolean"]} },
           "uniforms": { 
             "type": "object", 
             "additionalProperties": { "$ref": "#/definitions/uniformSpec" },
             "description": "Pass-specific uniforms. Merged with globals; pass-specific values take precedence."
           },
           "workgroups": { "type": "array", "items": {"type":"integer","minimum":1}, "minItems":1, "maxItems":3 },
           "viewport": { "type": "object", "properties": {"x":{"type":"integer"},"y":{"type":"integer"},"w":{"type":"integer"},"h":{"type":"integer"}} },
           "conditions": { 
             "type": "object", 
             "properties": { 
               "skipIf": { 
                 "type": "array",
                 "items": {
                   "type": "object",
                   "required": ["uniform", "equals"],
                   "properties": { "uniform": {"type":"string"}, "equals": {} }
                 }
               }, 
               "runIf": { 
                 "type": "array",
                 "items": {
                   "type": "object",
                   "required": ["uniform", "equals"],
                   "properties": { "uniform": {"type":"string"}, "equals": {} }
                 }
               } 
             } 
           },
           "barriers": { 
             "type": "array",
             "items": { "type": "string", "pattern": "^texture:[a-zA-Z0-9_]+:(fragment|compute)->(fragment|compute)$" },
             "description": "Explicit memory barriers. Format: 'texture:<name>:<stage>-><stage>'"
           },
           "readAfterWriteHazards": { 
             "type": "string", 
             "enum": ["allow","forbid"], 
             "default": "forbid",
             "description": "If 'allow', the runtime inserts a barrier between write and read within the same pass (if supported) or developer guarantees safety."
           }
         }
       }
     }
   }

Formats MUST map to backend-supported subsets:


* WebGL required: ``rgba8``, ``rgba16f``, ``rgba32f (if EXT_color_buffer_float)``, ``r8``.
* WebGPU required subset: ``rgba8unorm``, ``rgba16float``, ``rgba32float``, ``bgra8unorm``, depth formats as available.

7.1 Dimension Resolution Algorithm
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For each texture dimension (``width`` or ``height``), resolve to integer pixels:

.. code-block:: js

   function resolveDimension(spec, axis, screenSize) {
     if (typeof spec === 'number') return Math.max(1, Math.floor(spec))
     if (spec === 'screen') return screenSize[axis]
     if (spec === 'auto') return screenSize[axis] // Reserved; currently = screen

     if (typeof spec === 'string' && spec.endsWith('%')) {
       const percent = parseFloat(spec)
       const computed = Math.floor(screenSize[axis] * percent / 100)
       return Math.max(1, computed)
     }

     if (typeof spec === 'object' && spec.scale !== undefined) {
       let computed = Math.floor(screenSize[axis] * spec.scale)
       if (spec.clamp) {
         if (spec.clamp.min !== undefined) computed = Math.max(spec.clamp.min, computed)
         if (spec.clamp.max !== undefined) computed = Math.min(spec.clamp.max, computed)
       }
       return Math.max(1, computed)
     }

     throw new Error('ERR_INVALID_DIMENSION')
   }

All dimensions MUST be positive integers. Fractional results round down; minimum 1px enforced.

7.2 Format Negotiation
^^^^^^^^^^^^^^^^^^^^^^

When an effect requests a format unsupported by the active backend:


#. **Exact Match:** Use if available.
#. **Fallback Table:** Apply backend-specific mapping:

  .. code-block:: js

      const webglFallbacks = {
        'rgba16float': 'rgba16f',
        'rgba32float': hasExtension('EXT_color_buffer_float') ? 'rgba32f' : 'rgba16f',
        'rgba8unorm': 'rgba8'
      }

#. **Precision Downgrade:** If no mapping exists, select highest precision supported format with same channel count.
#. **Fail:** If no compatible format, emit ``ERR_FORMAT_UNSUPPORTED``.

Format selection MUST be deterministic and cached per backend context.
