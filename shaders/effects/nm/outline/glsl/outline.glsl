#version 300 es

precision highp float;
precision highp int;

// Outline final blend shader
// Performs: out = (invert ? (1.0 - edges) : edges) * base
// Edges texture is generated by preceding multi-pass pipeline (value map + sobel combine)

const uint CHANNEL_COUNT = 4u;


uniform sampler2D base_texture;
uniform float width;
uniform float height;
uniform float channel_count;
uniform float invert_flag;
uniform float sobel_metric;
uniform float time;
uniform float speed;
uniform sampler2D edges_texture;



out vec4 fragColor;

void main() {
    uvec3 global_id = uvec3(uint(gl_FragCoord.x), uint(gl_FragCoord.y), 0u);

    uint width = max(uint(width), 1u);
    uint height = max(uint(height), 1u);
    if (global_id.x >= width || global_id.y >= height) { return; }

    vec2 coord = vec2(int(global_id.x), int(global_id.y));
    vec4 base = texture(base_texture, (vec2(coord) + vec2(0.5)) / vec2(textureSize(base_texture, 0)));
    vec4 edges = texture(edges_texture, (vec2(coord) + vec2(0.5)) / vec2(textureSize(edges_texture, 0)));


    // Clamp edges (already normalized from sobel combine + optional normalize pass upstream)
    vec3 e = clamp(edges.xyz, vec3(0.0), vec3(1.0));
    // Black-edge overlay: darken base where edges are present
    float s = max(e.x, max(e.y, e.z));
    float strength = clamp(s, 0.0, 1.0);
    // If inverted, flip the strength (optional control)
    if (invert_flag > 0.5) {
        strength = 1.0 - strength;
    }
    vec3 out_rgb = mix(base.xyz, vec3(0.0), strength);
    vec4 out_color = vec4(out_rgb, base.w);
    uint base_index = (global_id.y * width + global_id.x) * CHANNEL_COUNT;
    fragColor = out_color;
}