<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noisemaker Rendering Pipeline - live demo</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23000'/%3E%3Cpath d='M2 2h12v12H2z' fill='%23f0f'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="../common.css" />
    <script type="importmap">
    {
        "imports": {
            "noisemaker/shader-effects": "../../shaders/src/runtime/effect.js"
        }
    }
    </script>
    <style>
    :root {
      --ui-accent: color-mix(in srgb, var(--accent3) 80%, var(--color7) 20%);
      --ui-neutral: var(--color6);
      --module-shared-accent: color-mix(in srgb, var(--accent1) 85%, var(--color6) 15%);
      --surface-opacity: 85%;
      --surface-transparency: 15%;
      --glass-blur-strength: blur(20px);
      --module-surface-opacity: 50%;
      --module-surface-transparency: 50%;
      --module-header-opacity: 29%;
      --module-header-transparency: 71%;
      --ui-corner-radius: 0.5rem;
      --ui-corner-radius-small: 0.375rem;
      --ui-corner-radius-large: 0.75rem;
      --ui-corner-radius-pill: 999px;
      --ui-chrome-highlight-blend: 86%;
      --ui-chrome-highlight-tint: 14%;
      --ui-chrome-shadow-blend: 72%;
      --ui-chrome-shadow-shade: 28%;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    :root {
      transition: background-color 0.3s ease;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Nunito, sans-serif;
      font-weight: 580;
      font-stretch: 108%;
      font-variation-settings: 'wght' 580;
      letter-spacing: 0.01em;
      background: var(--color1);
      color: var(--color6);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      text-size-adjust: none;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #app-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    /* Fixed canvas mode (default) */
    body.fixed-canvas-mode #canvas-container,
    body:not(.full-bleed-mode) #canvas-container {
      left: 440px;
      width: calc(100vw - 440px);
      height: 100vh;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      box-sizing: border-box;
    }

    body.fixed-canvas-mode #canvas,
    body:not(.full-bleed-mode) #canvas {
      /* Scale to fit available space while maintaining 1:1 aspect ratio */
      width: min(calc(100vw - 440px - 4rem), calc(100vh - 4rem));
      height: min(calc(100vw - 440px - 4rem), calc(100vh - 4rem));
      max-width: 100%;
      max-height: 100%;
      border: 1px solid color-mix(in srgb, var(--accent3) 30%, transparent 70%);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Full bleed mode */
    body.full-bleed-mode #canvas-container {
      justify-content: center;
    }

    body.full-bleed-mode #canvas {
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      /* Checkerboard pattern to show alpha transparency */
      background: 
        repeating-conic-gradient(
          color-mix(in srgb, var(--color2) 60%, var(--color1) 40%) 0% 25%, 
          color-mix(in srgb, var(--color3) 50%, var(--color2) 50%) 0% 50%
        ) 
        50% / 20px 20px;
    }

    #left-panel {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0;
      background: transparent;
      backdrop-filter: none;
      border: none;
      z-index: 100;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }

    #left-panel::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }

    .shader-module {
      background: color-mix(
        in srgb,
        var(--color2) var(--module-surface-opacity),
        transparent var(--module-surface-transparency)
      );
      backdrop-filter: var(--glass-blur-strength);
      border: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      border-radius: var(--ui-corner-radius);
      overflow: visible;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .module-title {
      background: color-mix(
        in srgb,
        var(--module-shared-accent) var(--module-header-opacity),
        transparent var(--module-header-transparency)
      );
      border-bottom: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      padding: 0.625em 0.875em;
      font-size: 0.75rem;
      font-weight: 700;
      font-variation-settings: 'wght' 700;
      color: color-mix(in srgb, var(--color6) 90%, var(--accent3) 10%);
      text-transform: lowercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.5em;
    }

    .module-title:hover {
      background: color-mix(
        in srgb,
        var(--module-shared-accent) calc(var(--module-header-opacity) + 5%),
        transparent calc(var(--module-header-transparency) - 5%)
      );
    }

    .module-title::before {
      content: 'â–¼';
      font-size: 0.65rem;
      transition: transform 0.2s ease;
      order: -1;
    }

    .shader-module.collapsed .module-title::before {
      transform: rotate(-90deg);
    }

    .module-content {
      padding: 0.5rem;
    }

    .shader-module.collapsed .module-content {
      display: none;
    }

    #status {
      display: none;
      min-height: 20px;
      font-size: 13px;
      color: #8fa8ff;
    }

    #controls {
      background: transparent;
      border: 1px solid color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border-radius: var(--ui-corner-radius);
      padding: 0.75rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }

    .control-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .control-label {
      font-size: 0.6875rem;
      font-weight: 600;
      font-variation-settings: 'wght' 600;
      color: color-mix(in srgb, var(--color6) 85%, var(--accent3) 15%);
      text-transform: lowercase;
      letter-spacing: 0.03em;
    }

    .control-value {
      font-size: 0.625rem;
      font-family: ui-monospace, "Cascadia Mono", "Consolas", monospace;
      color: color-mix(in srgb, var(--color5) 90%, var(--accent3) 10%);
    }

    .control-slider {
      width: 100%;
      height: 1.125rem;
      -webkit-appearance: none;
      appearance: none;
      background: color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border-radius: var(--ui-corner-radius-small);
      outline: none;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .control-slider:hover {
      background: color-mix(in srgb, var(--accent3) 22%, transparent 78%);
    }

    .control-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 0.875rem;
      height: 0.875rem;
      border-radius: 50%;
      background: var(--accent3);
      cursor: pointer;
      border: 2px solid color-mix(in srgb, var(--accent3) 100%, var(--color7) 0%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.15s ease;
    }

    .control-slider:hover::-webkit-slider-thumb {
      background: color-mix(in srgb, var(--accent3) 85%, var(--color7) 15%);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .control-slider::-moz-range-thumb {
      width: 0.875rem;
      height: 0.875rem;
      border-radius: 50%;
      background: var(--accent3);
      cursor: pointer;
      border: 2px solid color-mix(in srgb, var(--accent3) 100%, var(--color7) 0%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.15s ease;
    }

    .control-slider:hover::-moz-range-thumb {
      background: color-mix(in srgb, var(--accent3) 85%, var(--color7) 15%);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .control-select {
      width: 100%;
      padding: 0.25rem 0.375rem;
      background: color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      border-radius: var(--ui-corner-radius-small);
      color: var(--color6);
      font-family: Nunito, sans-serif;
      font-size: 0.6875rem;
      font-weight: 560;
      font-variation-settings: 'wght' 560;
      outline: none;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .control-select:hover {
      background: color-mix(in srgb, var(--accent3) 22%, transparent 78%);
      border-color: color-mix(in srgb, var(--accent3) 35%, transparent 65%);
    }

    .control-select:focus {
      border-color: var(--accent3);
      background: color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent3) 25%, transparent 75%);
    }

    /* Scrollbar styling for left panel */
    #left-panel::-webkit-scrollbar {
      width: 0.5rem;
    }

    #left-panel::-webkit-scrollbar-track {
      background: color-mix(in srgb, var(--accent3) 5%, transparent 95%);
      border-radius: var(--ui-corner-radius-small);
    }

    #left-panel::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--accent3) 30%, transparent 70%);
      border-radius: var(--ui-corner-radius-small);
      transition: background 0.15s ease;
    }

    #left-panel::-webkit-scrollbar-thumb:hover {
      background: color-mix(in srgb, var(--accent3) 50%, transparent 50%);
    }

    .status {
        position: fixed;
        bottom: 16px;
        right: 16px;
        background: #1a1a1a;
        border: 1px solid #333;
        padding: 8px 12px;
        font-size: 10px;
        color: #666;
        max-width: 300px;
        z-index: 1000;
    }

    .status.error {
        color: #d44;
        border-color: #d44;
    }

    .status.success {
        color: #4d4;
        border-color: #4d4;
    }

    .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-size: 12px;
        color: #666;
    }
    </style>
</head>
<body>
    <div id="loading" class="loading">loading effects...</div>
    <div id="app-container" style="display: none;">
        <div id="left-panel">
            <div class="shader-module">
                <div class="module-title">Noisemaker Rendering Pipeline</div>
                <div class="module-content">
                    <div class="control-group">
                        <div class="control-header">
                            <label for="effect-select" class="control-label">effect</label>
                        </div>
                        <select id="effect-select" class="control-select"></select>
                    </div>

                    <div class="control-group">
                        <div class="control-header">
                            <label class="control-label">shader language</label>
                        </div>
                        <div class="radio-group" style="display: flex; gap: 1rem; margin-top: 0.5rem;">
                            <label class="radio-option" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                                <input type="radio" name="backend" value="glsl" checked>
                                <span>glsl</span>
                            </label>
                            <label class="radio-option" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                                <input type="radio" name="backend" value="wgsl">
                                <span>wgsl</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>

            <div class="shader-module">
                <div class="module-title">Parameters</div>
                <div class="module-content">
                    <div id="parameters"></div>
                </div>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas" width="1024" height="1024"></canvas>
        </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <script type="module">
        import { registerOp } from '../../shaders/src/lang/ops.js';
        import { registerStarterOps } from '../../shaders/src/lang/validator.js';
        import { createRuntime, recompile } from '../../shaders/src/runtime/compiler.js';
        import { registerEffect } from '../../shaders/src/runtime/registry.js';
        import { mergeIntoEnums } from '../../shaders/src/lang/enums.js';
        import { stdEnums } from '../../shaders/src/lang/std_enums.js';

        const loadingEl = document.getElementById('loading');
        const appEl = document.getElementById('app-container');
        const statusEl = document.getElementById('status');
        const effectSelect = document.getElementById('effect-select');
        const parametersEl = document.getElementById('parameters');
        const canvas = document.getElementById('canvas');

        let currentEffect = null;
        let currentBackend = 'glsl';
        let parameterValues = {};
        let pipeline = null;
        let animationFrameId = null;
        let animationTimerId = null;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        let lastFrameTime = performance.now();
        let enums = {};
        let uniformBindings = new Map();
        let currentDsl = '';

        // Render loop
        function scheduleNextFrame(targetTime) {
            if (animationTimerId !== null) {
                clearTimeout(animationTimerId);
            }

            const now = performance.now();
            const delay = Math.max(0, targetTime - now);

            animationTimerId = setTimeout(() => {
                animationFrameId = requestAnimationFrame(renderLoop);
            }, delay);
        }

        function renderLoop(time) {
            const delta = time - lastFrameTime;

            if (delta < TARGET_FRAME_TIME - 0.5) {
                scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
                return;
            }

            if (pipeline) {
                pipeline.render(time / 1000);
            }

            lastFrameTime = time - (delta % TARGET_FRAME_TIME);
            scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
        }

        scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);

        // Show status message
        function showStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        function cloneParamValue(value) {
            if (Array.isArray(value)) {
                return value.map((item) => item);
            }
            if (value && typeof value === 'object') {
                try {
                    return JSON.parse(JSON.stringify(value));
                } catch (_err) {
                    return value;
                }
            }
            return value;
        }

        function resolveEnumValue(path) {
            if (path === undefined || path === null) return null;
            if (typeof path === 'number' || typeof path === 'boolean') return path;
            if (typeof path !== 'string') return null;

            const segments = path.split('.').filter(Boolean);
            let node = enums;

            for (const segment of segments) {
                if (!node || node[segment] === undefined) {
                    return null;
                }
                node = node[segment];
            }

            if (typeof node === 'number' || typeof node === 'boolean') {
                return node;
            }
            if (node && typeof node === 'object' && node.value !== undefined) {
                return node.value;
            }

            return null;
        }

        function convertParameterForUniform(value, spec) {
            if (!spec) {
                return value;
            }

            if ((spec.enum || spec.enumPath || spec.type === 'member') && typeof value === 'string') {
                let enumValue = resolveEnumValue(value);
                if ((enumValue === null || enumValue === undefined) && (spec.enum || spec.enumPath)) {
                    const base = spec.enum || spec.enumPath;
                    enumValue = resolveEnumValue(`${base}.${value}`);
                }
                if (enumValue !== null && enumValue !== undefined) {
                    return enumValue;
                }
            }

            switch (spec.type) {
                case 'boolean':
                case 'button':
                    return !!value;
                case 'int':
                    return typeof value === 'number' ? Math.round(value) : parseInt(value, 10);
                case 'float':
                    return typeof value === 'number' ? value : parseFloat(value);
                case 'vec3':
                case 'vec4':
                    if (Array.isArray(value)) {
                        return value.map((component) => (typeof component === 'number' ? component : parseFloat(component)));
                    }
                    break;
                default:
                    break;
            }

            return value;
        }

        function buildUniformBindings() {
            uniformBindings = new Map();

            if (!pipeline || !pipeline.graph || !Array.isArray(pipeline.graph.passes)) {
                return;
            }

            if (!currentEffect || !currentEffect.instance || !currentEffect.instance.globals) {
                return;
            }

            const targetFunc = currentEffect.instance.func;
            const targetNamespace = currentEffect.instance.namespace || currentEffect.namespace || null;

            pipeline.graph.passes.forEach((pass, index) => {
                if (!pass) return;

                const passFunc = pass.effectFunc || pass.effectKey || null;
                const passNamespace = pass.effectNamespace || null;

                if (!passFunc || passFunc !== targetFunc) return;
                if (targetNamespace && passNamespace && passNamespace !== targetNamespace) return;

                for (const [paramName, spec] of Object.entries(currentEffect.instance.globals)) {
                    if (spec.type === 'surface') continue;
                    const uniformName = spec.uniform || paramName;
                    if (!pass.uniforms || !(uniformName in pass.uniforms)) continue;

                    if (!uniformBindings.has(paramName)) {
                        uniformBindings.set(paramName, []);
                    }

                    uniformBindings.get(paramName).push({
                        passIndex: index,
                        uniformName
                    });
                }
            });
        }

        function applyParameterValues({ silent = false } = {}) {
            if (!pipeline || !currentEffect || !currentEffect.instance) {
                return;
            }

            if (!uniformBindings.size) {
                buildUniformBindings();
            }

            const globals = currentEffect.instance.globals || {};

            for (const [paramName, spec] of Object.entries(globals)) {
                if (spec.type === 'surface') {
                    continue;
                }
                const bindings = uniformBindings.get(paramName);
                if (!bindings || bindings.length === 0) {
                    continue;
                }

                const currentValue = parameterValues[paramName];
                if (currentValue === undefined) {
                    continue;
                }
                const converted = convertParameterForUniform(currentValue, spec);

                for (const binding of bindings) {
                    const pass = pipeline.graph.passes[binding.passIndex];
                    if (!pass || !pass.uniforms) {
                        continue;
                    }
                    pass.uniforms[binding.uniformName] = Array.isArray(converted) ? converted.slice() : converted;
                }
            }

            if (!silent) {
                // Avoid spamming the status overlay during rapid parameter changes
                // Future hook could go here if we want lightweight feedback
            }
        }

        function buildDslSource(effect) {
            if (!effect || !effect.instance) {
                return '';
            }

            const params = [];
            const surfaceTargets = new Set();

            if (effect.instance.globals) {
                for (const [key, spec] of Object.entries(effect.instance.globals)) {
                    const value = parameterValues[key];
                    if (value === undefined) {
                        continue;
                    }

                    if (spec.type === 'surface' && typeof value === 'string') {
                        surfaceTargets.add(value);
                    }

                    params.push(`${key}: ${formatValue(value, spec.type)}`);
                }
            }

            const paramString = params.join(', ');

            // Use namespaced function call to avoid ambiguity
            const funcName = effect.namespace ? `${effect.namespace}.${effect.instance.func}` : effect.instance.func;

            const preludeLines = [];
            let seedBase = 11;

            surfaceTargets.forEach(surface => {
                if (!surface || surface === 'o0') {
                    return;
                }
                preludeLines.push(`noise(seed: ${seedBase}).out(${surface})`);
                seedBase += 1;
            });

            let mainChain;
            if (isStarterEffect(effect)) {
                mainChain = `${funcName}(${paramString}).out(o0)`;
            } else {
                mainChain = `noise().${funcName}(${paramString}).out(o0)`;
            }

            if (preludeLines.length > 0) {
                return `${preludeLines.join('\n')}
${mainChain}`;
            }

            return mainChain;
        }

        async function rebuildPipeline({ silent = false } = {}) {
            if (!currentEffect) {
                return;
            }

            const dsl = buildDslSource(currentEffect);
            currentDsl = dsl;
            console.log('DSL', currentEffect.namespace + '/' + currentEffect.name, '\n' + dsl);

            try {
                if (!pipeline) {
                    pipeline = await createRuntime(dsl, {
                        canvas: canvas,
                        width: 1024,
                        height: 1024,
                        preferWebGPU: currentBackend === 'wgsl'
                    });
                } else {
                    const newGraph = recompile(pipeline, dsl);
                    if (!newGraph) {
                        pipeline = await createRuntime(dsl, {
                            canvas: canvas,
                            width: 1024,
                            height: 1024,
                            preferWebGPU: currentBackend === 'wgsl'
                        });
                    } else {
                        await pipeline.compilePrograms();
                    }
                }

                    window.__noisemakerRenderingPipeline = pipeline;

                uniformBindings = new Map();
                buildUniformBindings();
                applyParameterValues({ silent: true });

                if (!silent) {
                    showStatus(`compiled ${currentEffect.name}`, 'success');
                }
            } catch (err) {
                console.error(err);
                showStatus(`compilation failed: ${err.message}`, 'error');
            }
        }

        // Load all effect definitions dynamically
        async function loadEffects() {
            const effectDirs = [
                { namespace: 'basics', path: '../../shaders/effects/basics' },
                { namespace: 'nd', path: '../../shaders/effects/nd' },
                { namespace: 'nm', path: '../../shaders/effects/nm' }
            ];

            const effects = [];

            for (const dir of effectDirs) {
                try {
                    const effectNames = await fetchEffectList(dir.path);
                    
                    for (const effectName of effectNames) {
                        try {
                            const module = await import(`${dir.path}/${effectName}/definition.js`);
                            const EffectClass = module.default;
                            
                            if (EffectClass) {
                                const instance = new EffectClass();
                                
                                // Load shaders for each pass
                                if (instance.passes) {
                                    if (!instance.shaders) instance.shaders = {};
                                    for (const pass of instance.passes) {
                                        if (pass.program) {
                                            const existingShaders = instance.shaders[pass.program];
                                            const hasInlineShaders = !!(pass.programSpec && (pass.programSpec.fragment || pass.programSpec.vertex)) ||
                                                !!(existingShaders && (existingShaders.fragment || existingShaders.vertex || existingShaders.glsl || existingShaders.wgsl));
                                            try {
                                                if (!hasInlineShaders) {
                                                    const glslRes = await fetch(`${dir.path}/${effectName}/glsl/${pass.program}.glsl`);
                                                    if (glslRes.ok) {
                                                        const shaderBucket = instance.shaders[pass.program] ?? (instance.shaders[pass.program] = {});
                                                        shaderBucket.glsl = await glslRes.text();
                                                    }
                                                }
                                            } catch (e) {
                                                console.warn(`Failed to load shaders for ${pass.program}`, e);
                                            }
                                        }
                                    }
                                }

                                effects.push({
                                    namespace: dir.namespace,
                                    name: effectName,
                                    instance: instance
                                });

                                // Register effect
                                registerEffect(instance.func, instance);
                                registerEffect(`${dir.namespace}.${instance.func}`, instance);

                                // Register as operator
                                if (instance.func) {
                                    const args = Object.entries(instance.globals || {}).map(([key, spec]) => ({
                                        name: key,
                                        type: spec.type === 'vec4' ? 'color' : spec.type,
                                        default: spec.default,
                                        enum: spec.enum,
                                        enumPath: spec.enumPath,
                                        min: spec.min,
                                        max: spec.max,
                                        uniform: spec.uniform
                                    }));
                                    
                                    const opSpec = {
                                        name: instance.func,
                                        args: args
                                    };
                                    registerOp(instance.func, opSpec);
                                    registerOp(`${dir.namespace}.${instance.func}`, opSpec);
                                }
                            }
                        } catch (err) {
                            console.warn(`Failed to load effect ${dir.namespace}/${effectName}:`, err);
                        }
                    }
                } catch (err) {
                    console.warn(`Failed to load effects from ${dir.path}:`, err);
                }
            }

            return effects;
        }

        // Fetch list of effects in a directory
        async function fetchEffectList(basePath) {
            const lists = {
                '../../shaders/effects/basics': [
                    'add', 'alpha', 'blend', 'blue', 'brightness', 'color', 'colorparty', 'contrast', 'diff', 'gradient', 'green', 'hue', 'invert', 'kaleid', 'layer', 'luma', 'mask', 'modulate', 'modulateHue', 'modulateKaleid', 'modulatePixelate', 'modulateRepeat', 'modulateRepeatX', 'modulateRepeatY', 'modulateRotate', 'modulateScale', 'modulateScrollX', 'modulateScrollY', 'mult', 'noise', 'osc', 'pixelate', 'posterize', 'prev', 'red', 'repeat', 'repeatX', 'repeatY', 'rot', 'saturate', 'scale', 'scroll', 'scrollX', 'scrollY', 'shape', 'shift', 'solid', 'src', 'sub', 'sum', 'thresh', 'translate', 'voronoi'
                ],
                '../../shaders/effects/nd': [
                    'atmosphere', 'background', 'bit-effects', 'cell-noise', 'cell-refract', 'cellular-automata', 'cellular-automata-mn', 'coalesce', 'color-lab', 'composite', 'demo-synth', 'depth-of-field', 'displace-mixer', 'effects', 'erosion-worms', 'feedback-mixer', 'feedback-post', 'feedback-synth', 'final', 'fractal', 'glitch', 'kaleido', 'lens-distortion', 'media-input', 'media-mixer', 'media-post', 'noise', 'noise-3d', 'palette', 'pattern', 'physarum', 'reaction-diffusion', 'refract', 'shape-mixer', 'shapes', 'shapes-3d', 'splat', 'text', 'tunnel', 'warp', 'wgsl-mixer-demo', 'wgsl-post-demo', 'worms'
                ],
                '../../shaders/effects/nm': [
                    'aberration', 'adjust_brightness', 'adjust_contrast', 'adjust_hue', 'adjust_saturation', 'bloom', 'blur', 'clouds', 'color_map', 'conv_feedback', 'convolve', 'crt', 'degauss', 'density_map', 'derivative', 'dla', 'erosion_worms', 'false_color', 'fibers', 'frame', 'fxaa', 'glowing_edges', 'glyph_map', 'grain', 'grime', 'jpeg_decimate', 'kaleido', 'lens_distortion', 'lens_warp', 'light_leak', 'lowpoly', 'nebula', 'normal_map', 'normalize', 'on_screen_display', 'outline', 'palette', 'pixel_sort', 'posterize', 'refract', 'reindex', 'reverb', 'ridge', 'ripple', 'rotate', 'scanline_error', 'scratches', 'shadow', 'simple_frame', 'sine', 'sketch', 'snow', 'sobel', 'spatter', 'spooky_ticker', 'stray_hair', 'texture', 'tint', 'value_refract', 'vaseline', 'vhs', 'vignette', 'voronoi', 'vortex', 'warp', 'wobble', 'wormhole', 'worms'
                ]
            };

            return lists[basePath] || [];
        }

        // Initialize starter ops
        function initStarterOps(effects) {
            const starterNames = effects
                .filter(e => isStarterEffect(e))
                .map(e => e.instance.func || e.name)
                .filter(name => name);

            if (starterNames.length > 0) {
                registerStarterOps(starterNames);
            }
        }

        // Populate effect selector
        function populateEffectSelector(effects) {
            effectSelect.innerHTML = '';
            
            const grouped = {};
            effects.forEach(effect => {
                if (!grouped[effect.namespace]) {
                    grouped[effect.namespace] = [];
                }
                grouped[effect.namespace].push(effect);
            });

            const sortedNamespaces = Object.keys(grouped).sort((a, b) => {
                if (a === 'basics') return -1;
                if (b === 'basics') return 1;
                return a.localeCompare(b);
            });

            sortedNamespaces.forEach(namespace => {
                const effectList = grouped[namespace];
                const optgroup = document.createElement('optgroup');
                optgroup.label = namespace;
                
                effectList.sort((a, b) => a.name.localeCompare(b.name)).forEach(effect => {
                    const option = document.createElement('option');
                    option.value = `${namespace}/${effect.name}`;
                    option.textContent = effect.name;
                    optgroup.appendChild(option);
                });
                
                effectSelect.appendChild(optgroup);
            });

            // Select 'noise' effect by default
            for (let i = 0; i < effectSelect.options.length; i++) {
                if (effectSelect.options[i].value === 'basics/noise') {
                    effectSelect.selectedIndex = i;
                    break;
                }
            }
        }

        // Create parameter controls
        function createParameterControls(effect) {
            parametersEl.innerHTML = '';
            parameterValues = {};

            if (!effect.instance.globals) {
                return;
            }

            Object.entries(effect.instance.globals).forEach(([key, spec]) => {
                if (spec.ui && spec.ui.control === false) return;

                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';

                const header = document.createElement('div');
                header.className = 'control-header';
                
                const label = document.createElement('label');
                label.className = 'control-label';
                label.textContent = spec.ui?.label || key;
                header.appendChild(label);
                
                controlGroup.appendChild(header);

                const value = cloneParamValue(spec.default);
                parameterValues[key] = value;

                if (spec.type === 'boolean') {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = value;
                    checkbox.addEventListener('change', (e) => {
                        parameterValues[key] = e.target.checked;
                        applyParameterValues();
                    });
                    // Checkboxes are small, maybe put them in header or just append
                    // For consistency with other controls, let's put it below
                    controlGroup.appendChild(checkbox);
                } else if (spec.type === 'surface') {
                    const select = document.createElement('select');
                    select.className = 'control-select';
                    const surfaces = spec.options?.surfaces || ['o0', 'o1', 'o2', 'o3', 'o4', 'o5', 'o6', 'o7'];

                    surfaces.forEach(surfaceName => {
                        const option = document.createElement('option');
                        option.value = surfaceName;
                        option.textContent = surfaceName;
                        option.selected = surfaceName === value;
                        select.appendChild(option);
                    });

                    select.addEventListener('change', async (e) => {
                        parameterValues[key] = e.target.value;
                        await rebuildPipeline({ silent: true });
                    });

                    controlGroup.appendChild(select);
                    const normalized = typeof value === 'string' && surfaces.includes(value) ? value : surfaces[0];
                    select.value = normalized;
                    parameterValues[key] = normalized;
                } else if (spec.choices) {
                    const select = document.createElement('select');
                    select.className = 'control-select';
                    Object.entries(spec.choices).forEach(([name, val]) => {
                        if (name.endsWith(':')) return; // Skip category headers
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = name;
                        option.selected = val === value;
                        select.appendChild(option);
                    });
                    select.addEventListener('change', (e) => {
                        parameterValues[key] = spec.type === 'int' ? parseInt(e.target.value) : parseFloat(e.target.value);
                        applyParameterValues();
                    });
                    controlGroup.appendChild(select);
                } else if (spec.type === 'member') {
                    // Resolve enum path
                    let enumPath = spec.enum || spec.enumPath;
                    if (!enumPath && typeof spec.default === 'string') {
                        // Infer from default value like "noise.color.rgb" -> "noise.color"
                        const parts = spec.default.split('.');
                        if (parts.length > 1) {
                            enumPath = parts.slice(0, -1).join('.');
                        }
                    }

                    if (enumPath) {
                        // Traverse enums
                        const parts = enumPath.split('.');
                        let node = enums;
                        for (const part of parts) {
                            if (node && node[part]) {
                                node = node[part];
                            } else {
                                node = null;
                                break;
                            }
                        }

                        if (node) {
                            const select = document.createElement('select');
                            select.className = 'control-select';
                            // Iterate over keys
                            Object.keys(node).forEach(key => {
                                const option = document.createElement('option');
                                const fullPath = `${enumPath}.${key}`;
                                option.value = fullPath;
                                option.textContent = key;
                                option.selected = fullPath === value;
                                select.appendChild(option);
                            });
                            
                            select.addEventListener('change', (e) => {
                                parameterValues[key] = e.target.value;
                                applyParameterValues();
                            });
                            controlGroup.appendChild(select);
                        }
                    }
                } else if (spec.type === 'float' || spec.type === 'int') {
                    // Add value display to header
                    const valueDisplay = document.createElement('span');
                    valueDisplay.className = 'control-value';
                    valueDisplay.textContent = value !== null ? value : '';
                    header.appendChild(valueDisplay);

                    const slider = document.createElement('input');
                    slider.className = 'control-slider';
                    slider.type = 'range';
                    slider.min = spec.min !== undefined ? spec.min : 0;
                    slider.max = spec.max !== undefined ? spec.max : 100;
                    slider.step = spec.step !== undefined ? spec.step : (spec.type === 'int' ? 1 : 0.01);
                    slider.value = value !== null ? value : slider.min;

                    const updateValue = (val) => {
                        const numVal = spec.type === 'int' ? parseInt(val) : parseFloat(val);
                        slider.value = numVal;
                        valueDisplay.textContent = numVal;
                        parameterValues[key] = numVal;
                        applyParameterValues();
                    };

                    slider.addEventListener('input', (e) => updateValue(e.target.value));
                    controlGroup.appendChild(slider);
                } else if (spec.type === 'vec4') {
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    
                    // Convert [r,g,b,a] to #RRGGBB for the input
                    const toHex = (n) => Math.round(n * 255).toString(16).padStart(2, '0');
                    const r = toHex(value[0]);
                    const g = toHex(value[1]);
                    const b = toHex(value[2]);
                    colorInput.value = `#${r}${g}${b}`;

                    colorInput.addEventListener('input', (e) => {
                        const hex = e.target.value;
                        const r = parseInt(hex.slice(1, 3), 16) / 255;
                        const g = parseInt(hex.slice(3, 5), 16) / 255;
                        const b = parseInt(hex.slice(5, 7), 16) / 255;
                        // Preserve original alpha
                        const a = Array.isArray(parameterValues[key]) ? parameterValues[key][3] : 1;
                        parameterValues[key] = [r, g, b, a];
                        applyParameterValues();
                    });
                    controlGroup.appendChild(colorInput);
                } else if (spec.type === 'button') {
                    const button = document.createElement('button');
                    button.textContent = spec.ui?.label || key;
                    button.style.width = '100%';
                    button.style.padding = '8px';
                    button.style.background = '#333';
                    button.style.color = '#fff';
                    button.style.border = '1px solid #444';
                    button.style.cursor = 'pointer';
                    
                    button.addEventListener('mousedown', () => {
                        parameterValues[key] = true;
                        applyParameterValues({ silent: true });
                    });
                    
                    button.addEventListener('mouseup', () => {
                        parameterValues[key] = false;
                        applyParameterValues({ silent: true });
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        if (parameterValues[key]) {
                            parameterValues[key] = false;
                            applyParameterValues({ silent: true });
                        }
                    });
                    
                    controlGroup.appendChild(button);
                }

                parametersEl.appendChild(controlGroup);
            });
        }

        // Helper to format values for DSL
        function formatValue(value, type) {
            if (type === 'boolean' || type === 'button') {
                return value ? 'true' : 'false';
            }
            if (type === 'surface') {
                if (typeof value !== 'string' || value.length === 0) {
                    return 'src(o0)';
                }
                if (value.includes('(')) {
                    return value;
                }
                return `src(${value})`;
            }
            if (type === 'member') {
                return value; // e.g. "noise.color.rgb"
            }
            if (type === 'vec4' && Array.isArray(value)) {
                const toHex = (n) => {
                    const hex = Math.round(n * 255).toString(16).padStart(2, '0');
                    return hex;
                };
                return `#${toHex(value[0])}${toHex(value[1])}${toHex(value[2])}${toHex(value[3])}`;
            }
            if (type === 'vec3' && Array.isArray(value)) {
                return `vec3(${value.join(', ')})`;
            }
            if (type === 'vec2' && Array.isArray(value)) {
                return `vec2(${value.join(', ')})`;
            }
            if (type === 'palette' || type === 'string' || type === 'text') {
                return `"${value}"`;
            }
            // float, int
            return value;
        }

        // Helper to check if effect is starter
        function isStarterEffect(effect) {
            const firstPass = effect.instance.passes?.[0];
            if (!firstPass || !firstPass.inputs) return true;
            
            const inputs = Object.values(firstPass.inputs);
            // Check if any input maps to a pipeline input (usually 'inputColor' or similar)
            const pipelineInputs = [
                'inputTex', 'src',
                'o0', 'o1', 'o2', 'o3', 'o4', 'o5', 'o6', 'o7'
            ];
            const hasPipelineInput = inputs.some(val => pipelineInputs.includes(val));
            
            return !hasPipelineInput;
        }

        // Select and load an effect
        async function selectEffect(effectPath, allEffects) {
            const [namespace, name] = effectPath.split('/');
            
            const effect = allEffects.find(e => e.namespace === namespace && e.name === name);
            
            if (!effect) {
                showStatus(`effect ${namespace}/${name} not found`, 'error');
                return;
            }

            currentEffect = effect;
            createParameterControls(currentEffect);
            showStatus(`selected ${namespace}/${name}`, 'success');
            await rebuildPipeline();
        }

        // Backend selector
        document.querySelectorAll('input[name="backend"]').forEach(radio => {
            radio.addEventListener('change', async (e) => {
                currentBackend = e.target.value;
                showStatus(`switched to ${currentBackend}`, 'success');
                await rebuildPipeline({ silent: true });
            });
        });

        // Effect selector
        let allLoadedEffects = [];
        effectSelect.addEventListener('change', async (e) => {
            await selectEffect(e.target.value, allLoadedEffects);
        });

        // Get effect from URL query parameter
        function getEffectFromURL() {
            const params = new URLSearchParams(window.location.search);
            const effectParam = params.get('effect');
            
            if (!effectParam) return null;
            
            // Convert from "namespace.effectName" to "namespace/effectName"
            const parts = effectParam.split('.');
            if (parts.length === 2) {
                return `${parts[0]}/${parts[1]}`;
            }
            
            return null;
        }

        // Initialize the demo
        async function init() {
            try {
                enums = await mergeIntoEnums(stdEnums);
                const effects = await loadEffects();
                allLoadedEffects = effects;
                initStarterOps(effects);
                populateEffectSelector(effects);
                
                loadingEl.style.display = 'none';
                appEl.style.display = 'block';

                // Check for effect in URL query parameter
                const urlEffect = getEffectFromURL();
                let selectedEffect = null;

                if (urlEffect) {
                    // Verify the effect exists
                    const [namespace, name] = urlEffect.split('/');
                    const effect = effects.find(e => e.namespace === namespace && e.name === name);
                    
                    if (effect) {
                        selectedEffect = urlEffect;
                        // Update the select element to match
                        for (let i = 0; i < effectSelect.options.length; i++) {
                            if (effectSelect.options[i].value === urlEffect) {
                                effectSelect.selectedIndex = i;
                                break;
                            }
                        }
                    } else {
                        console.warn(`Effect "${urlEffect}" from URL not found`);
                    }
                }

                // Select effect (from URL or default)
                if (!selectedEffect && effectSelect.options.length > 0) {
                    selectedEffect = effectSelect.value;
                }

                if (selectedEffect) {
                    await selectEffect(selectedEffect, effects);
                }
                
                showStatus('demo loaded successfully', 'success');
            } catch (err) {
                console.error('Initialization failed:', err);
                loadingEl.textContent = `error: ${err.message}`;
                loadingEl.style.color = '#d44';
            }
        }

        init();
    </script>
</body>
</html>
