<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noisemaker Rendering Pipeline - live demo</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23000'/%3E%3Cpath d='M2 2h12v12H2z' fill='%23f0f'/%3E%3C/svg%3E">
    <link rel="stylesheet" href="../common.css" />
    <script type="importmap">
    {
        "imports": {
            "noisemaker/shader-effects": "../../shaders/src/runtime/effect.js"
        }
    }
    </script>
    <style>
    :root {
      --ui-accent: color-mix(in srgb, var(--accent3) 80%, var(--color7) 20%);
      --ui-neutral: var(--color6);
      --module-shared-accent: color-mix(in srgb, var(--accent1) 85%, var(--color6) 15%);
      --surface-opacity: 85%;
      --surface-transparency: 15%;
      --glass-blur-strength: blur(20px);
      --module-surface-opacity: 50%;
      --module-surface-transparency: 50%;
      --module-header-opacity: 29%;
      --module-header-transparency: 71%;
      --ui-corner-radius: 0.5rem;
      --ui-corner-radius-small: 0.375rem;
      --ui-corner-radius-large: 0.75rem;
      --ui-corner-radius-pill: 999px;
      --ui-chrome-highlight-blend: 86%;
      --ui-chrome-highlight-tint: 14%;
      --ui-chrome-shadow-blend: 72%;
      --ui-chrome-shadow-shade: 28%;
    }

    *,
    *::before,
    *::after {
      box-sizing: border-box;
    }

    :root {
      transition: background-color 0.3s ease;
    }

    html, body {
      margin: 0;
      padding: 0;
    }

    body {
      font-family: Nunito, sans-serif;
      font-weight: 580;
      font-stretch: 108%;
      font-variation-settings: 'wght' 580;
      letter-spacing: 0.01em;
      background: var(--color1);
      color: var(--color6);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      text-size-adjust: none;
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    #app-container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    #canvas-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.3s ease;
    }

    /* Fixed canvas mode (default) */
    body.fixed-canvas-mode #canvas-container,
    body:not(.full-bleed-mode) #canvas-container {
      left: 440px;
      width: calc(100vw - 440px);
      height: 100vh;
      justify-content: center;
      align-items: center;
      padding: 2rem;
      box-sizing: border-box;
    }

    body.fixed-canvas-mode #canvas,
    body:not(.full-bleed-mode) #canvas {
      /* Scale to fit available space while maintaining 1:1 aspect ratio */
      width: min(calc(100vw - 440px - 4rem), calc(100vh - 4rem));
      height: min(calc(100vw - 440px - 4rem), calc(100vh - 4rem));
      max-width: 100%;
      max-height: 100%;
      border: 1px solid color-mix(in srgb, var(--accent3) 30%, transparent 70%);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    /* Full bleed mode */
    body.full-bleed-mode #canvas-container {
      justify-content: center;
    }

    body.full-bleed-mode #canvas {
      width: 100vw;
      height: 100vh;
    }

    #canvas {
      /* Checkerboard pattern to show alpha transparency */
      background: 
        repeating-conic-gradient(
          color-mix(in srgb, var(--color2) 60%, var(--color1) 40%) 0% 25%, 
          color-mix(in srgb, var(--color3) 50%, var(--color2) 50%) 0% 50%
        ) 
        50% / 20px 20px;
    }

    #left-panel {
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 400px;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 0;
      background: transparent;
      backdrop-filter: none;
      border: none;
      z-index: 100;
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none; /* IE/Edge */
    }

    #left-panel::-webkit-scrollbar {
      display: none; /* Chrome/Safari/Opera */
    }

    .shader-module {
      background: color-mix(
        in srgb,
        var(--color2) var(--module-surface-opacity),
        transparent var(--module-surface-transparency)
      );
      backdrop-filter: var(--glass-blur-strength);
      border: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      border-radius: var(--ui-corner-radius);
      overflow: visible;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .module-title {
      background: color-mix(
        in srgb,
        var(--module-shared-accent) var(--module-header-opacity),
        transparent var(--module-header-transparency)
      );
      border-bottom: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      padding: 0.625em 0.875em;
      font-size: 0.75rem;
      font-weight: 700;
      font-variation-settings: 'wght' 700;
      color: color-mix(in srgb, var(--color6) 90%, var(--accent3) 10%);
      text-transform: lowercase;
      letter-spacing: 0.05em;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 0.5em;
    }

    .module-title:hover {
      background: color-mix(
        in srgb,
        var(--module-shared-accent) calc(var(--module-header-opacity) + 5%),
        transparent calc(var(--module-header-transparency) - 5%)
      );
    }

    .module-title::before {
      content: 'â–¼';
      font-size: 0.65rem;
      transition: transform 0.2s ease;
      order: -1;
    }

    .shader-module.collapsed .module-title::before {
      transform: rotate(-90deg);
    }

    .module-content {
      padding: 0.5rem;
    }

    .shader-module.collapsed .module-content {
      display: none;
    }

    #dsl-run-btn:hover {
      background: color-mix(in srgb, var(--accent3) 50%, transparent 50%);
      border-color: var(--accent3);
    }

    #dsl-run-btn:active {
      background: color-mix(in srgb, var(--accent3) 70%, transparent 30%);
      transform: translateY(1px);
    }

    #dsl-editor:focus {
      outline: none;
      border-color: color-mix(in srgb, var(--accent3) 50%, transparent 50%);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent3) 20%, transparent 80%);
    }

    #status {
      display: none;
      min-height: 20px;
      font-size: 13px;
      color: #8fa8ff;
    }

    #controls {
      background: transparent;
      border: 1px solid color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border-radius: var(--ui-corner-radius);
      padding: 0.75rem;
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 0.5rem;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
      margin-bottom: 0.5rem;
    }

    .control-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .control-label {
      font-size: 0.6875rem;
      font-weight: 600;
      font-variation-settings: 'wght' 600;
      color: color-mix(in srgb, var(--color6) 85%, var(--accent3) 15%);
      text-transform: lowercase;
      letter-spacing: 0.03em;
    }

    .control-value {
      font-size: 0.625rem;
      font-family: ui-monospace, "Cascadia Mono", "Consolas", monospace;
      color: color-mix(in srgb, var(--color5) 90%, var(--accent3) 10%);
    }

    .control-slider {
      width: 100%;
      height: 1.125rem;
      -webkit-appearance: none;
      appearance: none;
      background: color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border-radius: var(--ui-corner-radius-small);
      outline: none;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .control-slider:hover {
      background: color-mix(in srgb, var(--accent3) 22%, transparent 78%);
    }

    .control-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 0.875rem;
      height: 0.875rem;
      border-radius: 50%;
      background: var(--accent3);
      cursor: pointer;
      border: 2px solid color-mix(in srgb, var(--accent3) 100%, var(--color7) 0%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.15s ease;
    }

    .control-slider:hover::-webkit-slider-thumb {
      background: color-mix(in srgb, var(--accent3) 85%, var(--color7) 15%);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .control-slider::-moz-range-thumb {
      width: 0.875rem;
      height: 0.875rem;
      border-radius: 50%;
      background: var(--accent3);
      cursor: pointer;
      border: 2px solid color-mix(in srgb, var(--accent3) 100%, var(--color7) 0%);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: all 0.15s ease;
    }

    .control-slider:hover::-moz-range-thumb {
      background: color-mix(in srgb, var(--accent3) 85%, var(--color7) 15%);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);
    }

    .control-select {
      width: 100%;
      padding: 0.25rem 0.375rem;
      background: color-mix(in srgb, var(--accent3) 15%, transparent 85%);
      border: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      border-radius: var(--ui-corner-radius-small);
      color: var(--color6);
      font-family: Nunito, sans-serif;
      font-size: 0.6875rem;
      font-weight: 560;
      font-variation-settings: 'wght' 560;
      outline: none;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .control-select:hover {
      background: color-mix(in srgb, var(--accent3) 22%, transparent 78%);
      border-color: color-mix(in srgb, var(--accent3) 35%, transparent 65%);
    }

    .control-select:focus {
      border-color: var(--accent3);
      background: color-mix(in srgb, var(--accent3) 25%, transparent 75%);
      box-shadow: 0 0 0 2px color-mix(in srgb, var(--accent3) 25%, transparent 75%);
    }

    /* Scrollbar styling for left panel */
    #left-panel::-webkit-scrollbar {
      width: 0.5rem;
    }

    #left-panel::-webkit-scrollbar-track {
      background: color-mix(in srgb, var(--accent3) 5%, transparent 95%);
      border-radius: var(--ui-corner-radius-small);
    }

    #left-panel::-webkit-scrollbar-thumb {
      background: color-mix(in srgb, var(--accent3) 30%, transparent 70%);
      border-radius: var(--ui-corner-radius-small);
      transition: background 0.15s ease;
    }

    #left-panel::-webkit-scrollbar-thumb:hover {
      background: color-mix(in srgb, var(--accent3) 50%, transparent 50%);
    }

    .status {
        position: fixed;
        bottom: 16px;
        right: 16px;
        background: #1a1a1a;
        border: 1px solid #333;
        padding: 8px 12px;
        font-size: 10px;
        color: #666;
        max-width: 300px;
        z-index: 1000;
    }

    .status.error {
        color: #d44;
        border-color: #d44;
    }

    .status.success {
        color: #4d4;
        border-color: #4d4;
    }

    .loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        font-size: 12px;
        color: #666;
    }
    </style>
</head>
<body>
    <div id="loading" class="loading">loading effects...</div>
    <div id="app-container" style="display: none;">
        <div id="left-panel">
            <div class="shader-module">
                <div class="module-title">Noisemaker Rendering Pipeline</div>
                <div class="module-content">
                    <div class="control-group">
                        <div class="control-header">
                            <label for="effect-select" class="control-label">effect</label>
                        </div>
                        <select id="effect-select" class="control-select"></select>
                    </div>

                    <div class="control-group" style="display: flex; flex-direction: row !important; gap: 1.5rem; align-items: center; flex-wrap: wrap;">
                        <label class="radio-option" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                            <input type="radio" name="backend" value="glsl" checked>
                            <span>glsl</span>
                        </label>
                        <label class="radio-option" style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                            <input type="radio" name="backend" value="wgsl">
                            <span>wgsl</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                            <span>duration</span>
                            <input type="number" id="duration-input" class="control-select" value="10" min="1" max="300" step="1" style="width: 4rem;">
                        </label>
                        <label style="display: flex; align-items: center; gap: 0.5rem; font-size: 0.75rem; color: var(--color6);">
                            <span>fps</span>
                            <select id="fps-select" class="control-select">
                                <option value="30">30</option>
                                <option value="60" selected>60</option>
                                <option value="120">120</option>
                            </select>
                        </label>
                    </div>
                </div>
            </div>

            <div class="shader-module">
                <div class="module-title">DSL Program</div>
                <div class="module-content">
                    <textarea id="dsl-editor" spellcheck="false" style="margin: 0; padding: 0.5rem; width: 100%; min-height: 120px; resize: vertical; background: color-mix(in srgb, var(--color1) 60%, transparent 40%); border: 1px solid color-mix(in srgb, var(--accent3) 25%, transparent 75%); border-radius: var(--ui-corner-radius-small); font-family: ui-monospace, 'Cascadia Mono', 'Consolas', monospace; font-size: 0.6875rem; line-height: 1.4; color: var(--color5); box-sizing: border-box;"></textarea>
                    <div style="display: flex; gap: 0.5rem; margin-top: 0.5rem;">
                        <button id="dsl-run-btn" style="flex: 1; padding: 0.375rem 0.75rem; background: color-mix(in srgb, var(--accent3) 30%, transparent 70%); border: 1px solid color-mix(in srgb, var(--accent3) 50%, transparent 50%); border-radius: var(--ui-corner-radius-small); color: var(--color6); font-family: Nunito, sans-serif; font-size: 0.6875rem; font-weight: 600; cursor: pointer; transition: all 0.15s ease;">run</button>
                    </div>
                </div>
            </div>

            <div id="effect-controls-container">
                <!-- Dynamic effect controls will be inserted here -->
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="canvas" width="1024" height="1024"></canvas>
        </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <script type="module">
        import { registerOp } from '../../shaders/src/lang/ops.js';
        import { registerStarterOps } from '../../shaders/src/lang/validator.js';
        import { createRuntime, recompile } from '../../shaders/src/runtime/compiler.js';
        import { registerEffect, getEffect } from '../../shaders/src/runtime/registry.js';
        import { mergeIntoEnums } from '../../shaders/src/lang/enums.js';
        import { stdEnums } from '../../shaders/src/lang/std_enums.js';
        import { compile } from '../../shaders/src/lang/index.js';

        const loadingEl = document.getElementById('loading');
        const appEl = document.getElementById('app-container');
        const statusEl = document.getElementById('status');
        const effectSelect = document.getElementById('effect-select');
        const effectControlsContainer = document.getElementById('effect-controls-container');
        const dslEditor = document.getElementById('dsl-editor');
        const dslRunBtn = document.getElementById('dsl-run-btn');
        const canvasContainer = document.getElementById('canvas-container');
        let canvas = document.getElementById('canvas');

        let currentEffect = null;
        let currentBackend = 'glsl';
        let parameterValues = {};
        let effectParameterValues = {}; // Map: effectKey -> {param: value}
        let pipeline = null;

        // Expose backend and registry for testing
        window.__noisemakerCurrentBackend = () => currentBackend;
        window.__noisemakerRegistry = { getEffect };
        window.__noisemakerFrameCount = 0;
        window.__noisemakerGetLoopDuration = () => loopDuration;
        window.__noisemakerGetFPS = () => TARGET_FPS;
        let animationFrameId = null;
        let animationTimerId = null;
        let TARGET_FPS = 60;
        let TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        let loopDuration = 10; // Duration in seconds for one complete loop (time goes from 0 to 1)
        let lastFrameTime = performance.now();
        let loopStartTime = performance.now();
        let enums = {};
        let uniformBindings = new Map();
        let currentDsl = '';

        function resetCanvasElement() {
            if (!canvasContainer || !canvas) {
                return;
            }

            const newCanvas = canvas.cloneNode(false);
            newCanvas.id = canvas.id;
            newCanvas.width = canvas.width;
            newCanvas.height = canvas.height;

            canvasContainer.replaceChild(newCanvas, canvas);
            canvas = newCanvas;
        }

        async function disposePipeline({ loseContext = false, resetCanvas = false } = {}) {
            if (!pipeline) {
                if (resetCanvas) {
                    resetCanvasElement();
                }
                return;
            }

            const oldPipeline = pipeline;
            pipeline = null;
            window.__noisemakerRenderingPipeline = null;
            uniformBindings = new Map();

            try {
                oldPipeline.backend?.destroy?.({ loseContext });
            } catch (err) {
                console.warn('Failed to destroy pipeline backend', err);
            }

            if (resetCanvas) {
                resetCanvasElement();
            }
        }

        // Render loop
        function scheduleNextFrame(targetTime) {
            if (animationTimerId !== null) {
                clearTimeout(animationTimerId);
            }

            const now = performance.now();
            const delay = Math.max(0, targetTime - now);

            animationTimerId = setTimeout(() => {
                animationFrameId = requestAnimationFrame(renderLoop);
            }, delay);
        }

        function renderLoop(time) {
            const delta = time - lastFrameTime;

            if (delta < TARGET_FRAME_TIME - 0.5) {
                scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
                return;
            }

            if (pipeline) {
                try {
                    // Calculate normalized time (0 to 1) based on loop duration
                    const elapsedSeconds = (time - loopStartTime) / 1000;
                    const normalizedTime = (elapsedSeconds % loopDuration) / loopDuration;
                    pipeline.render(normalizedTime);
                } catch (err) {
                    console.error('Render loop error:', err);
                }
                window.__noisemakerFrameCount++;
            }

            lastFrameTime = time - (delta % TARGET_FRAME_TIME);
            scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
        }

        scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);

        // Show status message
        function showStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        function cloneParamValue(value) {
            if (Array.isArray(value)) {
                return value.map((item) => item);
            }
            if (value && typeof value === 'object') {
                try {
                    return JSON.parse(JSON.stringify(value));
                } catch (_err) {
                    return value;
                }
            }
            return value;
        }

        function resolveEnumValue(path) {
            if (path === undefined || path === null) return null;
            if (typeof path === 'number' || typeof path === 'boolean') return path;
            if (typeof path !== 'string') return null;

            const segments = path.split('.').filter(Boolean);
            let node = enums;

            for (const segment of segments) {
                if (!node || node[segment] === undefined) {
                    return null;
                }
                node = node[segment];
            }

            if (typeof node === 'number' || typeof node === 'boolean') {
                return node;
            }
            if (node && typeof node === 'object' && node.value !== undefined) {
                return node.value;
            }

            return null;
        }

        function convertParameterForUniform(value, spec) {
            if (!spec) {
                return value;
            }

            if ((spec.enum || spec.enumPath || spec.type === 'member') && typeof value === 'string') {
                let enumValue = resolveEnumValue(value);
                if ((enumValue === null || enumValue === undefined) && (spec.enum || spec.enumPath)) {
                    const base = spec.enum || spec.enumPath;
                    enumValue = resolveEnumValue(`${base}.${value}`);
                }
                if (enumValue !== null && enumValue !== undefined) {
                    return enumValue;
                }
            }

            switch (spec.type) {
                case 'boolean':
                case 'button':
                    return !!value;
                case 'int':
                    return typeof value === 'number' ? Math.round(value) : parseInt(value, 10);
                case 'float':
                    return typeof value === 'number' ? value : parseFloat(value);
                case 'vec3':
                case 'vec4':
                    if (Array.isArray(value)) {
                        return value.map((component) => (typeof component === 'number' ? component : parseFloat(component)));
                    }
                    break;
                default:
                    break;
            }

            return value;
        }

        function buildUniformBindings() {
            uniformBindings = new Map();

            if (!pipeline || !pipeline.graph || !Array.isArray(pipeline.graph.passes)) {
                return;
            }

            if (!currentEffect || !currentEffect.instance || !currentEffect.instance.globals) {
                return;
            }

            const targetFunc = currentEffect.instance.func;
            const targetNamespace = currentEffect.instance.namespace || currentEffect.namespace || null;

            pipeline.graph.passes.forEach((pass, index) => {
                if (!pass) return;

                const passFunc = pass.effectFunc || pass.effectKey || null;
                const passNamespace = pass.effectNamespace || null;

                if (!passFunc || passFunc !== targetFunc) return;
                if (targetNamespace && passNamespace && passNamespace !== targetNamespace) return;

                for (const [paramName, spec] of Object.entries(currentEffect.instance.globals)) {
                    if (spec.type === 'surface') continue;
                    const uniformName = spec.uniform || paramName;
                    if (!pass.uniforms || !(uniformName in pass.uniforms)) continue;

                    if (!uniformBindings.has(paramName)) {
                        uniformBindings.set(paramName, []);
                    }

                    uniformBindings.get(paramName).push({
                        passIndex: index,
                        uniformName
                    });
                }
            });
        }

        function applyParameterValues({ silent = false } = {}) {
            if (!pipeline || !currentEffect || !currentEffect.instance) {
                return;
            }

            if (!uniformBindings.size) {
                buildUniformBindings();
            }

            const globals = currentEffect.instance.globals || {};

            for (const [paramName, spec] of Object.entries(globals)) {
                if (spec.type === 'surface') {
                    continue;
                }
                const bindings = uniformBindings.get(paramName);
                if (!bindings || bindings.length === 0) {
                    continue;
                }

                const currentValue = parameterValues[paramName];
                if (currentValue === undefined) {
                    continue;
                }
                const converted = convertParameterForUniform(currentValue, spec);

                for (const binding of bindings) {
                    const pass = pipeline.graph.passes[binding.passIndex];
                    if (!pass || !pass.uniforms) {
                        continue;
                    }
                    pass.uniforms[binding.uniformName] = Array.isArray(converted) ? converted.slice() : converted;
                }
            }

            if (!silent) {
                // Avoid spamming the status overlay during rapid parameter changes
                // Future hook could go here if we want lightweight feedback
            }
        }

        // Check if effect has a 'tex' surface parameter (for mixer-type effects)
        function hasTexSurfaceParam(effect) {
            if (!effect || !effect.instance || !effect.instance.globals) {
                return false;
            }
            const texSpec = effect.instance.globals.tex;
            return texSpec && texSpec.type === 'surface';
        }

        function buildDslSource(effect) {
            if (!effect || !effect.instance) {
                return '';
            }

            // Build search directive if effect has a namespace
            // nm effects need basics too for generators like noise
            let searchNs = effect.namespace;
            if (effect.namespace === 'nm') {
                searchNs = 'nm, basics';
            }
            const searchDirective = searchNs ? `search ${searchNs}\n` : '';
            const funcName = effect.instance.func;

            // Determine effect category
            const starter = isStarterEffect(effect);
            const hasTex = hasTexSurfaceParam(effect);

            if (starter) {
                // Starter effect: effectName(...).out(o0)
                const params = [];
                if (effect.instance.globals) {
                    for (const [key, spec] of Object.entries(effect.instance.globals)) {
                        const value = parameterValues[key];
                        if (value === undefined || value === null) {
                            continue;
                        }
                        params.push(`${key}: ${formatValue(value, spec.type)}`);
                    }
                }
                const paramString = params.join(', ');
                // Special case: pass-through effects with surface param need source content
                // e.g., src(tex: src(o1)) needs o1 to have content first
                // The pipeline always presents o0 to screen, so we use o1 as intermediate
                // and output to o0.
                if (hasTex) {
                    // Always use o1 as intermediate surface and o0 as output
                    const sourceSurface = 'o1';
                    const outputSurface = 'o0';
                    // Ensure tex parameter is passed to the effect
                    const paramsWithTex = paramString ? `tex: src(${sourceSurface}), ${paramString}` : `tex: src(${sourceSurface})`;
                    return `${searchDirective}noise(seed: 1, ridges: true).out(${sourceSurface})\n${funcName}(${paramsWithTex}).out(${outputSurface})`;
                }
                return `${searchDirective}${funcName}(${paramString}).out(o0)`;
            } else if (hasTex) {
                // Mixer effect (has inputTex and tex): two noise sources
                // The pipeline always presents o0 to screen, so output to o0
                // noise(seed: 1, ridged: true).out(o1)
                // noise(seed: 2, ridged: true).effectName(tex: src(o1), ...).out(o0)
                const params = [];
                // Always include tex: src(o1) for mixer effects
                params.push(`tex: src(o1)`);
                if (effect.instance.globals) {
                    for (const [key, spec] of Object.entries(effect.instance.globals)) {
                        // Skip tex - we already added it above
                        if (key === 'tex' && spec.type === 'surface') {
                            continue;
                        }
                        const value = parameterValues[key];
                        if (value === undefined || value === null) {
                            continue;
                        }
                        params.push(`${key}: ${formatValue(value, spec.type)}`);
                    }
                }
                const paramString = params.join(', ');
                return `${searchDirective}noise(seed: 1, ridges: true).out(o1)
noise(seed: 2, ridges: true).${funcName}(${paramString}).out(o0)`;
            } else {
                // Simple transform effect (has inputTex only): noise().effectName(...).out(o0)
                const params = [];
                if (effect.instance.globals) {
                    for (const [key, spec] of Object.entries(effect.instance.globals)) {
                        const value = parameterValues[key];
                        if (value === undefined || value === null) {
                            continue;
                        }
                        params.push(`${key}: ${formatValue(value, spec.type)}`);
                    }
                }
                const paramString = params.join(', ');
                return `${searchDirective}noise(seed: 1, ridges: true).${funcName}(${paramString}).out(o0)`;
            }
        }

        /**
         * Extract effect calls from DSL source by parsing it
         * Returns array of { effectKey, namespace, name, args, stepIndex }
         */
        function extractEffectsFromDsl(dsl) {
            const effects = [];
            if (!dsl || typeof dsl !== 'string') return effects;

            try {
                const result = compile(dsl);
                if (!result || !result.plans) return effects;

                let globalStepIndex = 0;
                for (const plan of result.plans) {
                    if (!plan.chain) continue;
                    for (const step of plan.chain) {
                        const opName = step.op;
                        const namespace = step.namespace?.namespace || step.namespace?.call?.resolved || null;
                        
                        // Build the effect key for lookup
                        let effectKey = opName;
                        if (namespace) {
                            effectKey = `${namespace}/${opName}`;
                        }
                        
                        effects.push({
                            effectKey,
                            namespace,
                            name: opName,
                            args: step.args || {},
                            stepIndex: globalStepIndex,
                            temp: step.temp
                        });
                        globalStepIndex++;
                    }
                }
            } catch (err) {
                console.warn('Failed to parse DSL for effect extraction:', err);
            }

            return effects;
        }

        /**
         * Create effect controls from parsed DSL
         * Each effect gets its own visual container
         */
        function createEffectControlsFromDsl(dsl) {
            effectControlsContainer.innerHTML = '';
            effectParameterValues = {};

            const effects = extractEffectsFromDsl(dsl);
            if (effects.length === 0) return;

            for (const effectInfo of effects) {
                // Try to get the effect definition
                let effectDef = getEffect(effectInfo.effectKey);
                if (!effectDef && effectInfo.namespace) {
                    effectDef = getEffect(`${effectInfo.namespace}.${effectInfo.name}`);
                }
                if (!effectDef) {
                    effectDef = getEffect(effectInfo.name);
                }

                if (!effectDef || !effectDef.globals) continue;

                // Create container for this effect
                const moduleDiv = document.createElement('div');
                moduleDiv.className = 'shader-module';
                moduleDiv.dataset.stepIndex = effectInfo.stepIndex;
                moduleDiv.dataset.effectName = effectInfo.name;

                const titleDiv = document.createElement('div');
                titleDiv.className = 'module-title';
                titleDiv.textContent = effectInfo.namespace ? `${effectInfo.namespace}.${effectInfo.name}` : effectInfo.name;
                titleDiv.addEventListener('click', () => {
                    moduleDiv.classList.toggle('collapsed');
                });
                moduleDiv.appendChild(titleDiv);

                const contentDiv = document.createElement('div');
                contentDiv.className = 'module-content';

                const controlsDiv = document.createElement('div');
                controlsDiv.id = `controls-${effectInfo.stepIndex}`;
                controlsDiv.style.cssText = 'background: transparent; border: 1px solid color-mix(in srgb, var(--accent3) 15%, transparent 85%); border-radius: var(--ui-corner-radius); padding: 0.75rem; display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;';

                // Initialize parameter values for this effect from the DSL args
                const effectKey = `step_${effectInfo.stepIndex}`;
                effectParameterValues[effectKey] = {};

                // Create controls for each parameter
                for (const [key, spec] of Object.entries(effectDef.globals)) {
                    if (spec.ui && spec.ui.control === false) continue;
                    if (spec.type === 'surface') continue; // Skip surfaces for now

                    const controlGroup = document.createElement('div');
                    controlGroup.className = 'control-group';

                    const header = document.createElement('div');
                    header.className = 'control-header';
                    
                    const label = document.createElement('label');
                    label.className = 'control-label';
                    label.textContent = spec.ui?.label || key;
                    header.appendChild(label);
                    
                    controlGroup.appendChild(header);

                    // Get value from DSL args or use default
                    let value = effectInfo.args[key];
                    if (value === undefined) {
                        value = cloneParamValue(spec.default);
                    }
                    effectParameterValues[effectKey][key] = value;

                    // Create the appropriate control based on type
                    if (spec.type === 'boolean') {
                        const checkbox = document.createElement('input');
                        checkbox.type = 'checkbox';
                        checkbox.checked = !!value;
                        checkbox.addEventListener('change', (e) => {
                            effectParameterValues[effectKey][key] = e.target.checked;
                            updateDslFromEffectParams();
                        });
                        controlGroup.appendChild(checkbox);
                    } else if (spec.choices) {
                        const select = document.createElement('select');
                        select.className = 'control-select';

                        let selectedValue = null;
                        let optionIndex = 0;

                        Object.entries(spec.choices).forEach(([name, val]) => {
                            if (name.endsWith(':')) return;

                            const option = document.createElement('option');
                            option.value = String(optionIndex);
                            option.textContent = name;
                            option.dataset.paramValue = JSON.stringify(val);
                            if ((value === null && val === null) || value === val) {
                                option.selected = true;
                                selectedValue = option.value;
                            }
                            select.appendChild(option);
                            optionIndex += 1;
                        });

                        if (selectedValue !== null) {
                            select.value = selectedValue;
                        }

                        select.addEventListener('change', (e) => {
                            const target = e.target;
                            const option = target.options[target.selectedIndex];
                            const raw = option?.dataset?.paramValue;

                            let parsedValue = null;
                            if (raw !== undefined) {
                                try {
                                    parsedValue = JSON.parse(raw);
                                } catch (_err) {
                                    parsedValue = raw;
                                }
                            }

                            effectParameterValues[effectKey][key] = parsedValue;
                            updateDslFromEffectParams();
                        });

                        controlGroup.appendChild(select);
                    } else if (spec.type === 'member') {
                        let enumPath = spec.enum || spec.enumPath;
                        if (!enumPath && typeof spec.default === 'string') {
                            const parts = spec.default.split('.');
                            if (parts.length > 1) {
                                enumPath = parts.slice(0, -1).join('.');
                            }
                        }

                        if (enumPath) {
                            const parts = enumPath.split('.');
                            let node = enums;
                            for (const part of parts) {
                                if (node && node[part]) {
                                    node = node[part];
                                } else {
                                    node = null;
                                    break;
                                }
                            }

                            if (node) {
                                const select = document.createElement('select');
                                select.className = 'control-select';
                                Object.keys(node).forEach(k => {
                                    const option = document.createElement('option');
                                    const fullPath = `${enumPath}.${k}`;
                                    option.value = fullPath;
                                    option.textContent = k;
                                    option.selected = fullPath === value;
                                    select.appendChild(option);
                                });
                                
                                select.addEventListener('change', (e) => {
                                    effectParameterValues[effectKey][key] = e.target.value;
                                    updateDslFromEffectParams();
                                });
                                controlGroup.appendChild(select);
                            }
                        }
                    } else if (spec.type === 'float' || spec.type === 'int') {
                        const valueDisplay = document.createElement('span');
                        valueDisplay.className = 'control-value';
                        valueDisplay.textContent = value !== null ? value : '';
                        header.appendChild(valueDisplay);

                        const slider = document.createElement('input');
                        slider.className = 'control-slider';
                        slider.type = 'range';
                        slider.min = spec.min !== undefined ? spec.min : 0;
                        slider.max = spec.max !== undefined ? spec.max : 100;
                        slider.step = spec.step !== undefined ? spec.step : (spec.type === 'int' ? 1 : 0.01);
                        slider.value = value !== null ? value : slider.min;

                        slider.addEventListener('input', (e) => {
                            const numVal = spec.type === 'int' ? parseInt(e.target.value) : parseFloat(e.target.value);
                            valueDisplay.textContent = numVal;
                            effectParameterValues[effectKey][key] = numVal;
                            applyEffectParameterValues();
                        });
                        
                        slider.addEventListener('change', () => {
                            updateDslFromEffectParams();
                        });

                        controlGroup.appendChild(slider);
                    } else if (spec.type === 'vec4') {
                        const colorInput = document.createElement('input');
                        colorInput.type = 'color';
                        
                        if (Array.isArray(value)) {
                            const toHex = (n) => Math.round(n * 255).toString(16).padStart(2, '0');
                            colorInput.value = `#${toHex(value[0])}${toHex(value[1])}${toHex(value[2])}`;
                        }

                        colorInput.addEventListener('input', (e) => {
                            const hex = e.target.value;
                            const r = parseInt(hex.slice(1, 3), 16) / 255;
                            const g = parseInt(hex.slice(3, 5), 16) / 255;
                            const b = parseInt(hex.slice(5, 7), 16) / 255;
                            const a = Array.isArray(effectParameterValues[effectKey][key]) ? effectParameterValues[effectKey][key][3] : 1;
                            effectParameterValues[effectKey][key] = [r, g, b, a];
                            updateDslFromEffectParams();
                        });
                        controlGroup.appendChild(colorInput);
                    }

                    controlsDiv.appendChild(controlGroup);
                }

                contentDiv.appendChild(controlsDiv);
                moduleDiv.appendChild(contentDiv);
                effectControlsContainer.appendChild(moduleDiv);
            }
        }

        /**
         * Apply effect parameter values to the running pipeline
         * This is for real-time updates without recompiling
         */
        function applyEffectParameterValues() {
            if (!pipeline || !pipeline.graph || !pipeline.graph.passes) return;

            for (const [effectKey, params] of Object.entries(effectParameterValues)) {
                const stepIndex = parseInt(effectKey.replace('step_', ''), 10);
                
                for (const pass of pipeline.graph.passes) {
                    if (!pass.uniforms) continue;
                    
                    // Try to match pass to effect by nodeId
                    const nodeId = `node_${stepIndex}`;
                    if (pass.nodeId === nodeId) {
                        for (const [paramName, value] of Object.entries(params)) {
                            const effectDef = getEffect(pass.effectKey) || getEffect(pass.effectFunc);
                            if (!effectDef || !effectDef.globals) continue;
                            
                            const spec = effectDef.globals[paramName];
                            if (!spec || !spec.uniform) continue;
                            
                            const converted = convertParameterForUniform(value, spec);
                            pass.uniforms[spec.uniform] = Array.isArray(converted) ? converted.slice() : converted;
                        }
                    }
                }
            }
        }

        /**
         * Update DSL text from effect parameter values
         */
        function updateDslFromEffectParams() {
            const currentDslText = dslEditor.value;
            
            // For now, just rebuild the pipeline with current DSL
            // More sophisticated DSL text updating could be done by regenerating the DSL
            rebuildPipelineFromDsl();
        }

        /**
         * Rebuild pipeline from DSL editor content
         */
        async function rebuildPipelineFromDsl() {
            const dsl = dslEditor.value.trim();
            if (!dsl) {
                showStatus('DSL is empty', 'error');
                return;
            }

            currentDsl = dsl;
            window.__noisemakerCurrentDsl = dsl;

            try {
                if (!pipeline) {
                    pipeline = await createRuntime(dsl, {
                        canvas: canvas,
                        width: 1024,
                        height: 1024,
                        preferWebGPU: currentBackend === 'wgsl'
                    });
                } else {
                    const newGraph = recompile(pipeline, dsl);
                    if (!newGraph) {
                        const previousPipeline = pipeline;
                        pipeline = await createRuntime(dsl, {
                            canvas: canvas,
                            width: 1024,
                            height: 1024,
                            preferWebGPU: currentBackend === 'wgsl'
                        });
                        try {
                            previousPipeline?.backend?.destroy?.();
                        } catch (err) {
                            console.warn('Failed to release previous pipeline backend', err);
                        }
                    } else {
                        await pipeline.compilePrograms();
                    }
                }

                window.__noisemakerRenderingPipeline = pipeline;
                
                // Rebuild effect controls based on new DSL
                createEffectControlsFromDsl(dsl);
                
                showStatus('compiled successfully', 'success');
            } catch (err) {
                console.error('DSL compilation error:', err);
                let errMsg;
                if (err.code === 'ERR_COMPILATION_FAILED' && Array.isArray(err.diagnostics)) {
                    errMsg = err.diagnostics
                        .filter(d => d.severity === 'error')
                        .map(d => {
                            let msg = d.message || 'Unknown error';
                            if (d.location) {
                                msg += ` (line ${d.location.line}, col ${d.location.column})`;
                            }
                            return msg;
                        })
                        .join('; ') || 'Unknown compilation error';
                } else {
                    errMsg = err.message || err.detail || (typeof err === 'object' ? JSON.stringify(err) : String(err));
                }
                showStatus(`compilation failed: ${errMsg}`, 'error');
            }
        }

        async function rebuildPipeline({ silent = false } = {}) {
            if (!currentEffect) {
                return;
            }

            const verboseParams = Object.fromEntries(Object.entries(parameterValues).map(([k, v]) => [k, v]));
            console.log('Effect parameters', currentEffect.namespace + '/' + currentEffect.name, verboseParams);

            const dsl = buildDslSource(currentEffect);
            currentDsl = dsl;
            window.__noisemakerCurrentDsl = dsl;
            console.log('DSL', currentEffect.namespace + '/' + currentEffect.name, '\n' + dsl);

            // Update DSL editor
            dslEditor.value = dsl || '';

            try {
                if (!pipeline) {
                    pipeline = await createRuntime(dsl, {
                        canvas: canvas,
                        width: 1024,
                        height: 1024,
                        preferWebGPU: currentBackend === 'wgsl'
                    });
                    
                    // Provide zoom accessor
                    pipeline.getGlobalZoom = () => {
                        if (currentEffect && currentEffect.instance && currentEffect.instance.globals && currentEffect.instance.globals.zoom) {
                            return parameterValues.zoom || currentEffect.instance.globals.zoom.default || 1;
                        }
                        return 1;
                    };
                } else {
                    const newGraph = recompile(pipeline, dsl);
                    if (!newGraph) {
                        const previousPipeline = pipeline;
                        const rebuiltPipeline = await createRuntime(dsl, {
                            canvas: canvas,
                            width: 1024,
                            height: 1024,
                            preferWebGPU: currentBackend === 'wgsl'
                        });
                        pipeline = rebuiltPipeline;

                        try {
                            previousPipeline?.backend?.destroy?.();
                        } catch (err) {
                            console.warn('Failed to release previous pipeline backend', err);
                        }
                        
                        // Provide zoom accessor
                        pipeline.getGlobalZoom = () => {
                            if (currentEffect && currentEffect.instance && currentEffect.instance.globals && currentEffect.instance.globals.zoom) {
                                return parameterValues.zoom || currentEffect.instance.globals.zoom.default || 1;
                            }
                            return 1;
                        };
                    } else {
                        await pipeline.compilePrograms();
                    }
                }

                    window.__noisemakerRenderingPipeline = pipeline;
                    window.__noisemakerCurrentEffect = currentEffect;

                uniformBindings = new Map();
                buildUniformBindings();
                applyParameterValues({ silent: true });
                
                // Create effect controls from the generated DSL
                createEffectControlsFromDsl(dsl);

                if (!silent) {
                    showStatus(`compiled ${currentEffect.name}`, 'success');
                }
            } catch (err) {
                console.error(err);
                let errMsg;
                if (err.code === 'ERR_COMPILATION_FAILED' && Array.isArray(err.diagnostics)) {
                    // Format diagnostics with identifier context
                    errMsg = err.diagnostics
                        .filter(d => d.severity === 'error')
                        .map(d => {
                            let msg = d.message || 'Unknown error';
                            if (d.location) {
                                msg += ` (line ${d.location.line}, col ${d.location.column})`;
                            }
                            return msg;
                        })
                        .join('; ') || 'Unknown compilation error';
                } else {
                    errMsg = err.message || err.detail || (typeof err === 'object' ? JSON.stringify(err) : String(err));
                }
                showStatus(`compilation failed: ${errMsg}`, 'error');
            }
        }

        // Load all effect definitions dynamically
        async function loadEffects() {
            const effectDirs = [
                { namespace: 'basics', path: '../../shaders/effects/basics' },
                { namespace: 'nd', path: '../../shaders/effects/nd' },
                { namespace: 'nm', path: '../../shaders/effects/nm' },
                { namespace: 'nu', path: '../../shaders/effects/nu' }
            ];

            const effects = [];
            
            // Load the single top-level manifest
            let globalManifest = {};
            try {
                const manifestRes = await fetch('../../shaders/effects/manifest.json');
                if (manifestRes.ok) {
                    globalManifest = await manifestRes.json();
                }
            } catch (e) {
                console.warn('Failed to load shader manifest, will probe for files');
            }

            for (const dir of effectDirs) {
                try {
                    const effectNames = getEffectsFromManifest(globalManifest, dir.namespace);
                    
                    for (const effectName of effectNames) {
                        try {
                            const module = await import(`${dir.path}/${effectName}/definition.js`);
                            const EffectClass = module.default;
                            
                            if (EffectClass) {
                                const instance = new EffectClass();
                                const effectId = `${dir.namespace}/${effectName}`;
                                const manifest = globalManifest[effectId];
                                
                                // Load shaders for each pass (both GLSL and WGSL)
                                if (instance.passes) {
                                    if (!instance.shaders) instance.shaders = {};
                                    for (const pass of instance.passes) {
                                        if (pass.program) {
                                            try {
                                                const shaderBucket = instance.shaders[pass.program] ?? (instance.shaders[pass.program] = {});
                                                const prog = pass.program;
                                                
                                                // Use manifest to determine what to load (no 404s)
                                                if (manifest) {
                                                    // GLSL
                                                    const glslInfo = manifest.glsl?.[prog];
                                                    if (glslInfo === 'combined') {
                                                        const res = await fetch(`${dir.path}/${effectName}/glsl/${prog}.glsl`);
                                                        if (res.ok) shaderBucket.glsl = await res.text();
                                                    } else if (glslInfo) {
                                                        if (glslInfo.v) {
                                                            const res = await fetch(`${dir.path}/${effectName}/glsl/${prog}.vert`);
                                                            if (res.ok) shaderBucket.vertex = await res.text();
                                                        }
                                                        if (glslInfo.f) {
                                                            const res = await fetch(`${dir.path}/${effectName}/glsl/${prog}.frag`);
                                                            if (res.ok) shaderBucket.fragment = await res.text();
                                                        }
                                                    }
                                                    // WGSL
                                                    if (manifest.wgsl?.[prog]) {
                                                        const res = await fetch(`${dir.path}/${effectName}/wgsl/${prog}.wgsl`);
                                                        if (res.ok) shaderBucket.wgsl = await res.text();
                                                    }
                                                } else {
                                                    // Fallback: try to load without manifest (will cause 404s)
                                                    const glslRes = await fetch(`${dir.path}/${effectName}/glsl/${prog}.glsl`);
                                                    if (glslRes.ok) {
                                                        shaderBucket.glsl = await glslRes.text();
                                                    } else {
                                                        const [vertRes, fragRes] = await Promise.all([
                                                            fetch(`${dir.path}/${effectName}/glsl/${prog}.vert`),
                                                            fetch(`${dir.path}/${effectName}/glsl/${prog}.frag`)
                                                        ]);
                                                        if (vertRes.ok) shaderBucket.vertex = await vertRes.text();
                                                        if (fragRes.ok) shaderBucket.fragment = await fragRes.text();
                                                    }
                                                    const wgslRes = await fetch(`${dir.path}/${effectName}/wgsl/${prog}.wgsl`);
                                                    if (wgslRes.ok) shaderBucket.wgsl = await wgslRes.text();
                                                }
                                            } catch (e) {
                                                console.warn(`Failed to load shaders for ${pass.program}`, e);
                                            }
                                        }
                                    }
                                }

                                effects.push({
                                    namespace: dir.namespace,
                                    name: effectName,
                                    instance: instance
                                });

                                // Register effect with multiple names for lookup flexibility
                                registerEffect(instance.func, instance);
                                registerEffect(`${dir.namespace}.${instance.func}`, instance);
                                // Also register with directory name (for select option value lookup)
                                registerEffect(`${dir.namespace}/${effectName}`, instance);
                                registerEffect(`${dir.namespace}.${effectName}`, instance);

                                // Register as operator
                                if (instance.func) {
                                    const args = Object.entries(instance.globals || {}).map(([key, spec]) => ({
                                        name: key,
                                        type: spec.type === 'vec4' ? 'color' : spec.type,
                                        default: spec.default,
                                        enum: spec.enum,
                                        enumPath: spec.enumPath,
                                        min: spec.min,
                                        max: spec.max,
                                        uniform: spec.uniform
                                    }));
                                    
                                    const opSpec = {
                                        name: instance.func,
                                        args: args
                                    };
                                    // Only register namespaced names - bare names cause conflicts
                                    // (e.g., nm/voronoi vs basics/voronoi both registering 'voronoi')
                                    registerOp(`${dir.namespace}.${instance.func}`, opSpec);
                                }
                            }
                        } catch (err) {
                            console.warn(`Failed to load effect ${dir.namespace}/${effectName}:`, err);
                        }
                    }
                } catch (err) {
                    console.warn(`Failed to load effects from ${dir.path}:`, err);
                }
            }

            return effects;
        }

        // Extract effect names for a namespace from manifest keys
        function getEffectsFromManifest(manifest, namespace) {
            const prefix = `${namespace}/`;
            return Object.keys(manifest)
                .filter(key => key.startsWith(prefix))
                .map(key => key.slice(prefix.length))
                .sort();
        }

        // Initialize starter ops
        function initStarterOps(effects) {
            const starterNames = [];
            effects
                .filter(e => isStarterEffect(e))
                .forEach(e => {
                    const func = e.instance.func || e.name;
                    const namespace = e.namespace;
                    if (func) {
                        // Register both bare name and namespaced name
                        starterNames.push(func);
                        if (namespace) {
                            starterNames.push(`${namespace}.${func}`);
                        }
                    }
                });

            if (starterNames.length > 0) {
                registerStarterOps(starterNames);
            }
        }

        // Populate effect selector
        function populateEffectSelector(effects) {
            effectSelect.innerHTML = '';
            
            const grouped = {};
            effects.forEach(effect => {
                if (!grouped[effect.namespace]) {
                    grouped[effect.namespace] = [];
                }
                grouped[effect.namespace].push(effect);
            });

            const sortedNamespaces = Object.keys(grouped).sort((a, b) => {
                if (a === 'basics') return -1;
                if (b === 'basics') return 1;
                return a.localeCompare(b);
            });

            sortedNamespaces.forEach(namespace => {
                const effectList = grouped[namespace];
                const optgroup = document.createElement('optgroup');
                optgroup.label = namespace;
                
                effectList.sort((a, b) => a.name.localeCompare(b.name)).forEach(effect => {
                    const option = document.createElement('option');
                    option.value = `${namespace}/${effect.name}`;
                    option.textContent = effect.name;
                    optgroup.appendChild(option);
                });
                
                effectSelect.appendChild(optgroup);
            });

            // Select 'noise' effect by default
            for (let i = 0; i < effectSelect.options.length; i++) {
                if (effectSelect.options[i].value === 'basics/noise') {
                    effectSelect.selectedIndex = i;
                    break;
                }
            }
        }

        // Helper to format values for DSL
        function formatValue(value, type) {
            if (type === 'boolean' || type === 'button') {
                return value ? 'true' : 'false';
            }
            if (type === 'surface') {
                if (typeof value !== 'string' || value.length === 0) {
                    return 'src(o0)';
                }
                if (value.includes('(')) {
                    return value;
                }
                return `src(${value})`;
            }
            if (type === 'member') {
                return value; // e.g. "noise.color.rgb"
            }
            if (type === 'vec4' && Array.isArray(value)) {
                const toHex = (n) => {
                    const hex = Math.round(n * 255).toString(16).padStart(2, '0');
                    return hex;
                };
                return `#${toHex(value[0])}${toHex(value[1])}${toHex(value[2])}${toHex(value[3])}`;
            }
            if (type === 'vec3' && Array.isArray(value)) {
                return `vec3(${value.join(', ')})`;
            }
            if (type === 'vec2' && Array.isArray(value)) {
                return `vec2(${value.join(', ')})`;
            }
            if (type === 'palette' || type === 'string' || type === 'text') {
                return `"${value}"`;
            }
            // float, int
            return value;
        }

        // Helper to check if effect is starter
        function isStarterEffect(effect) {
            const passes = effect.instance.passes || [];
            if (passes.length === 0) return true;
            
            // Check if ANY pass uses a pipeline input (not just the first pass)
            // This handles effects like clouds which generate noise internally in early passes
            // but need inputTex in later passes for blending
            const pipelineInputs = [
                'inputTex', 'src',
                'o0', 'o1', 'o2', 'o3', 'o4', 'o5', 'o6', 'o7'
            ];
            
            for (const pass of passes) {
                if (!pass.inputs) continue;
                const inputs = Object.values(pass.inputs);
                const hasPipelineInput = inputs.some(val => pipelineInputs.includes(val));
                if (hasPipelineInput) {
                    return false; // Not a starter - needs external input
                }
            }
            
            return true; // No pass needs pipeline input - it's a starter
        }

        // Select and load an effect
        async function selectEffect(effectPath, allEffects) {
            const [namespace, name] = effectPath.split('/');
            
            const effect = allEffects.find(e => e.namespace === namespace && e.name === name);
            
            if (!effect) {
                showStatus(`effect ${namespace}/${name} not found`, 'error');
                return;
            }

            currentEffect = effect;
            showStatus(`selected ${namespace}/${name}`, 'success');
            
            // Properly dispose of the old pipeline before creating a new one
            await disposePipeline({ loseContext: false, resetCanvas: false });
            
            await rebuildPipeline();
        }

        // Backend selector
        document.querySelectorAll('input[name="backend"]').forEach(radio => {
            radio.addEventListener('change', async (e) => {
                const nextBackend = e.target.value;
                if (nextBackend === currentBackend) {
                    return;
                }

                const previousBackend = currentBackend;
                currentBackend = nextBackend;

                await disposePipeline({
                    loseContext: previousBackend === 'glsl',
                    resetCanvas: true
                });

                showStatus(`switched to ${currentBackend}`, 'success');
                await rebuildPipeline({ silent: true });
            });
        });

        // FPS selector
        document.getElementById('fps-select').addEventListener('change', (e) => {
            TARGET_FPS = parseInt(e.target.value, 10);
            TARGET_FRAME_TIME = 1000 / TARGET_FPS;
            showStatus(`fps set to ${TARGET_FPS}`, 'success');
        });

        // Duration input
        document.getElementById('duration-input').addEventListener('change', (e) => {
            const newDuration = parseFloat(e.target.value);
            if (newDuration >= 1 && newDuration <= 300) {
                loopDuration = newDuration;
                loopStartTime = performance.now(); // Reset loop to start
                showStatus(`duration set to ${loopDuration}s`, 'success');
            }
        });

        // DSL run button
        dslRunBtn.addEventListener('click', async () => {
            await rebuildPipelineFromDsl();
        });

        // DSL editor keyboard shortcut (Ctrl+Enter or Cmd+Enter to run)
        dslEditor.addEventListener('keydown', async (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                e.preventDefault();
                await rebuildPipelineFromDsl();
            }
        });

        // Check for backend in URL query parameter
        function getBackendFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('backend');
        }

        // Effect selector
        let allLoadedEffects = [];
        effectSelect.addEventListener('change', async (e) => {
            await selectEffect(e.target.value, allLoadedEffects);
        });

        // Get effect from URL query parameter
        function getEffectFromURL() {
            const params = new URLSearchParams(window.location.search);
            const effectParam = params.get('effect');
            
            if (!effectParam) return null;
            
            // Convert from "namespace.effectName" to "namespace/effectName"
            const parts = effectParam.split('.');
            if (parts.length === 2) {
                return `${parts[0]}/${parts[1]}`;
            }
            
            return null;
        }

        // Initialize the demo
        async function init() {
            try {
                enums = await mergeIntoEnums(stdEnums);
                const effects = await loadEffects();
                allLoadedEffects = effects;
                initStarterOps(effects);
                populateEffectSelector(effects);
                
                loadingEl.style.display = 'none';
                appEl.style.display = 'block';

                // Check for backend in URL query parameter
                const urlBackend = getBackendFromURL();
                if (urlBackend === 'wgsl' || urlBackend === 'glsl') {
                    currentBackend = urlBackend;
                    // Update radio button to match
                    const radio = document.querySelector(`input[name="backend"][value="${urlBackend}"]`);
                    if (radio) radio.checked = true;
                }

                // Check for effect in URL query parameter
                const urlEffect = getEffectFromURL();
                let selectedEffect = null;

                if (urlEffect) {
                    // Verify the effect exists
                    const [namespace, name] = urlEffect.split('/');
                    const effect = effects.find(e => e.namespace === namespace && e.name === name);
                    
                    if (effect) {
                        selectedEffect = urlEffect;
                        // Update the select element to match
                        for (let i = 0; i < effectSelect.options.length; i++) {
                            if (effectSelect.options[i].value === urlEffect) {
                                effectSelect.selectedIndex = i;
                                break;
                            }
                        }
                    } else {
                        console.warn(`Effect "${urlEffect}" from URL not found`);
                    }
                }

                // Select effect (from URL or default)
                if (!selectedEffect && effectSelect.options.length > 0) {
                    selectedEffect = effectSelect.value;
                }

                if (selectedEffect) {
                    await selectEffect(selectedEffect, effects);
                }
                
                showStatus('demo loaded successfully', 'success');
            } catch (err) {
                console.error('Initialization failed:', err);
                loadingEl.textContent = `error: ${err.message}`;
                loadingEl.style.color = '#d44';
            }
        }

        init();
    </script>
</body>
</html>
