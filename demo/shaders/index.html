<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noisemaker Rendering Pipeline - live demo</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3E%3Crect width='16' height='16' fill='%23000'/%3E%3Cpath d='M2 2h12v12H2z' fill='%23f0f'/%3E%3C/svg%3E">
    <script type="importmap">
    {
        "imports": {
            "noisemaker/shader-effects": "../../shaders/src/runtime/effect.js"
        }
    }
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', 'Consolas', monospace;
            background: #0a0a0a;
            color: #e0e0e0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            height: 100vh;
            gap: 0;
        }

        .controls {
            background: #0f0f0f;
            border-right: 1px solid #222;
            overflow-y: auto;
            padding: 16px;
        }

        .canvas-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: #000;
            padding: 20px;
        }

        h1 {
            font-size: 14px;
            font-weight: normal;
            color: #666;
            margin-bottom: 16px;
            text-transform: lowercase;
        }

        .control-group {
            margin-bottom: 16px;
        }

        label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 6px;
            text-transform: lowercase;
        }

        select, input[type="range"], input[type="number"], input[type="checkbox"] {
            width: 100%;
            background: #1a1a1a;
            border: 1px solid #333;
            color: #e0e0e0;
            padding: 8px;
            font-family: inherit;
            font-size: 12px;
            outline: none;
        }

        select {
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='6' viewBox='0 0 10 6' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M1 1L5 5L9 1' stroke='%23888' stroke-width='1.5' stroke-linecap='round'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            padding-right: 28px;
        }

        select:hover, select:focus {
            border-color: #555;
        }

        input[type="range"] {
            padding: 4px;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 14px;
            height: 14px;
            background: #666;
            cursor: pointer;
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #888;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #666;
            cursor: pointer;
            border-radius: 2px;
            border: none;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: #888;
        }

        input[type="number"] {
            width: 60px;
            padding: 4px 6px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: #666;
        }

        .slider-wrapper {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .slider-wrapper input[type="range"] {
            flex: 1;
        }

        .slider-wrapper input[type="number"] {
            flex-shrink: 0;
        }

        canvas {
            display: block;
            width: 1024px;
            height: 1024px;
            max-width: 100%;
            max-height: calc(100vh - 140px);
            border: 1px solid #222;
            background: #000;
        }

        .backend-selector {
            margin-top: 16px;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .backend-selector > label {
            margin: 0;
            font-size: 11px;
        }

        .radio-group {
            display: flex;
            gap: 16px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        .radio-option input[type="radio"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
            accent-color: #666;
        }

        .radio-option span {
            font-size: 11px;
            color: #888;
            text-transform: lowercase;
        }

        .parameters {
            max-height: calc(100vh - 280px);
            overflow-y: auto;
        }

        .parameters::-webkit-scrollbar {
            width: 8px;
        }

        .parameters::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .parameters::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .parameters::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .controls::-webkit-scrollbar {
            width: 8px;
        }

        .controls::-webkit-scrollbar-track {
            background: #0a0a0a;
        }

        .controls::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 4px;
        }

        .controls::-webkit-scrollbar-thumb:hover {
            background: #444;
        }

        .status {
            position: fixed;
            bottom: 16px;
            right: 16px;
            background: #1a1a1a;
            border: 1px solid #333;
            padding: 8px 12px;
            font-size: 10px;
            color: #666;
            max-width: 300px;
            z-index: 1000;
        }

        .status.error {
            color: #d44;
            border-color: #d44;
        }

        .status.success {
            color: #4d4;
            border-color: #4d4;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">loading effects...</div>
    <div id="app" class="container" style="display: none;">
        <div class="controls">
            <h1>Noisemaker Rendering Pipeline</h1>
            
            <div class="control-group">
                <label for="effect-select">effect</label>
                <select id="effect-select"></select>
            </div>

            <div class="parameters" id="parameters"></div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="1024" height="1024"></canvas>
            
            <div class="backend-selector">
                <label>shader language:</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="backend" value="glsl" checked>
                        <span>glsl</span>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="backend" value="wgsl">
                        <span>wgsl</span>
                    </label>
                </div>
            </div>
        </div>
    </div>

    <div id="status" class="status" style="display: none;"></div>

    <script type="module">
        import { registerOp } from '../../shaders/src/lang/ops.js';
        import { registerStarterOps } from '../../shaders/src/lang/validator.js';
        import { createRuntime, recompile } from '../../shaders/src/runtime/compiler.js';
        import { registerEffect } from '../../shaders/src/runtime/registry.js';
        import { mergeIntoEnums } from '../../shaders/src/lang/enums.js';
        import { stdEnums } from '../../shaders/src/lang/std_enums.js';

        const loadingEl = document.getElementById('loading');
        const appEl = document.getElementById('app');
        const statusEl = document.getElementById('status');
        const effectSelect = document.getElementById('effect-select');
        const parametersEl = document.getElementById('parameters');
        const canvas = document.getElementById('canvas');

        let currentEffect = null;
        let currentBackend = 'glsl';
        let parameterValues = {};
        let pipeline = null;
        let animationFrameId = null;
        let animationTimerId = null;
        const TARGET_FPS = 60;
        const TARGET_FRAME_TIME = 1000 / TARGET_FPS;
        let lastFrameTime = performance.now();
        let enums = {};
        let uniformBindings = new Map();
        let currentDsl = '';

        // Render loop
        function scheduleNextFrame(targetTime) {
            if (animationTimerId !== null) {
                clearTimeout(animationTimerId);
            }

            const now = performance.now();
            const delay = Math.max(0, targetTime - now);

            animationTimerId = setTimeout(() => {
                animationFrameId = requestAnimationFrame(renderLoop);
            }, delay);
        }

        function renderLoop(time) {
            const delta = time - lastFrameTime;

            if (delta < TARGET_FRAME_TIME - 0.5) {
                scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
                return;
            }

            if (pipeline) {
                pipeline.render(time / 1000);
            }

            lastFrameTime = time - (delta % TARGET_FRAME_TIME);
            scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);
        }

        scheduleNextFrame(lastFrameTime + TARGET_FRAME_TIME);

        // Show status message
        function showStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status ${type}`;
            statusEl.style.display = 'block';
            setTimeout(() => {
                statusEl.style.display = 'none';
            }, 3000);
        }

        function cloneParamValue(value) {
            if (Array.isArray(value)) {
                return value.map((item) => item);
            }
            if (value && typeof value === 'object') {
                try {
                    return JSON.parse(JSON.stringify(value));
                } catch (_err) {
                    return value;
                }
            }
            return value;
        }

        function resolveEnumValue(path) {
            if (path === undefined || path === null) return null;
            if (typeof path === 'number' || typeof path === 'boolean') return path;
            if (typeof path !== 'string') return null;

            const segments = path.split('.').filter(Boolean);
            let node = enums;

            for (const segment of segments) {
                if (!node || node[segment] === undefined) {
                    return null;
                }
                node = node[segment];
            }

            if (typeof node === 'number' || typeof node === 'boolean') {
                return node;
            }
            if (node && typeof node === 'object' && node.value !== undefined) {
                return node.value;
            }

            return null;
        }

        function convertParameterForUniform(value, spec) {
            if (!spec) {
                return value;
            }

            if ((spec.enum || spec.enumPath || spec.type === 'member') && typeof value === 'string') {
                let enumValue = resolveEnumValue(value);
                if ((enumValue === null || enumValue === undefined) && (spec.enum || spec.enumPath)) {
                    const base = spec.enum || spec.enumPath;
                    enumValue = resolveEnumValue(`${base}.${value}`);
                }
                if (enumValue !== null && enumValue !== undefined) {
                    return enumValue;
                }
            }

            switch (spec.type) {
                case 'boolean':
                case 'button':
                    return !!value;
                case 'int':
                    return typeof value === 'number' ? Math.round(value) : parseInt(value, 10);
                case 'float':
                    return typeof value === 'number' ? value : parseFloat(value);
                case 'vec3':
                case 'vec4':
                    if (Array.isArray(value)) {
                        return value.map((component) => (typeof component === 'number' ? component : parseFloat(component)));
                    }
                    break;
                default:
                    break;
            }

            return value;
        }

        function buildUniformBindings() {
            uniformBindings = new Map();

            if (!pipeline || !pipeline.graph || !Array.isArray(pipeline.graph.passes)) {
                return;
            }

            if (!currentEffect || !currentEffect.instance || !currentEffect.instance.globals) {
                return;
            }

            const targetFunc = currentEffect.instance.func;
            const targetNamespace = currentEffect.instance.namespace || currentEffect.namespace || null;

            pipeline.graph.passes.forEach((pass, index) => {
                if (!pass) return;

                const passFunc = pass.effectFunc || pass.effectKey || null;
                const passNamespace = pass.effectNamespace || null;

                if (!passFunc || passFunc !== targetFunc) return;
                if (targetNamespace && passNamespace && passNamespace !== targetNamespace) return;

                for (const [paramName, spec] of Object.entries(currentEffect.instance.globals)) {
                    if (spec.type === 'surface') continue;
                    const uniformName = spec.uniform || paramName;
                    if (!pass.uniforms || !(uniformName in pass.uniforms)) continue;

                    if (!uniformBindings.has(paramName)) {
                        uniformBindings.set(paramName, []);
                    }

                    uniformBindings.get(paramName).push({
                        passIndex: index,
                        uniformName
                    });
                }
            });
        }

        function applyParameterValues({ silent = false } = {}) {
            if (!pipeline || !currentEffect || !currentEffect.instance) {
                return;
            }

            if (!uniformBindings.size) {
                buildUniformBindings();
            }

            const globals = currentEffect.instance.globals || {};

            for (const [paramName, spec] of Object.entries(globals)) {
                if (spec.type === 'surface') {
                    continue;
                }
                const bindings = uniformBindings.get(paramName);
                if (!bindings || bindings.length === 0) {
                    continue;
                }

                const currentValue = parameterValues[paramName];
                if (currentValue === undefined) {
                    continue;
                }
                const converted = convertParameterForUniform(currentValue, spec);

                for (const binding of bindings) {
                    const pass = pipeline.graph.passes[binding.passIndex];
                    if (!pass || !pass.uniforms) {
                        continue;
                    }
                    pass.uniforms[binding.uniformName] = Array.isArray(converted) ? converted.slice() : converted;
                }
            }

            if (!silent) {
                // Avoid spamming the status overlay during rapid parameter changes
                // Future hook could go here if we want lightweight feedback
            }
        }

        function buildDslSource(effect) {
            if (!effect || !effect.instance) {
                return '';
            }

            const params = [];
            const surfaceTargets = new Set();

            if (effect.instance.globals) {
                for (const [key, spec] of Object.entries(effect.instance.globals)) {
                    const value = parameterValues[key];
                    if (value === undefined) {
                        continue;
                    }

                    if (spec.type === 'surface' && typeof value === 'string') {
                        surfaceTargets.add(value);
                    }

                    params.push(`${key}: ${formatValue(value, spec.type)}`);
                }
            }

            const paramString = params.join(', ');

            // Use namespaced function call to avoid ambiguity
            const funcName = effect.namespace ? `${effect.namespace}.${effect.instance.func}` : effect.instance.func;

            const preludeLines = [];
            let seedBase = 11;

            surfaceTargets.forEach(surface => {
                if (!surface || surface === 'o0') {
                    return;
                }
                preludeLines.push(`noise(seed: ${seedBase}).out(${surface})`);
                seedBase += 1;
            });

            let mainChain;
            if (isStarterEffect(effect)) {
                mainChain = `${funcName}(${paramString}).out(o0)`;
            } else {
                mainChain = `noise().${funcName}(${paramString}).out(o0)`;
            }

            if (preludeLines.length > 0) {
                return `${preludeLines.join('\n')}
${mainChain}`;
            }

            return mainChain;
        }

        async function rebuildPipeline({ silent = false } = {}) {
            if (!currentEffect) {
                return;
            }

            const dsl = buildDslSource(currentEffect);
            currentDsl = dsl;
            console.log('DSL', currentEffect.namespace + '/' + currentEffect.name, '\n' + dsl);

            try {
                if (!pipeline) {
                    pipeline = await createRuntime(dsl, {
                        canvas: canvas,
                        width: 1024,
                        height: 1024,
                        preferWebGPU: currentBackend === 'wgsl'
                    });
                } else {
                    const newGraph = recompile(pipeline, dsl);
                    if (!newGraph) {
                        pipeline = await createRuntime(dsl, {
                            canvas: canvas,
                            width: 1024,
                            height: 1024,
                            preferWebGPU: currentBackend === 'wgsl'
                        });
                    } else {
                        await pipeline.compilePrograms();
                    }
                }

                    window.__noisemakerRenderingPipeline = pipeline;

                uniformBindings = new Map();
                buildUniformBindings();
                applyParameterValues({ silent: true });

                if (!silent) {
                    showStatus(`compiled ${currentEffect.name}`, 'success');
                }
            } catch (err) {
                console.error(err);
                showStatus(`compilation failed: ${err.message}`, 'error');
            }
        }

        // Load all effect definitions dynamically
        async function loadEffects() {
            const effectDirs = [
                { namespace: 'basics', path: '../../shaders/effects/basics' },
                { namespace: 'nd', path: '../../shaders/effects/nd' },
                { namespace: 'nm', path: '../../shaders/effects/nm' }
            ];

            const effects = [];

            for (const dir of effectDirs) {
                try {
                    const effectNames = await fetchEffectList(dir.path);
                    
                    for (const effectName of effectNames) {
                        try {
                            const module = await import(`${dir.path}/${effectName}/definition.js`);
                            const EffectClass = module.default;
                            
                            if (EffectClass) {
                                const instance = new EffectClass();
                                
                                // Load shaders for each pass
                                if (instance.passes) {
                                    if (!instance.shaders) instance.shaders = {};
                                    for (const pass of instance.passes) {
                                        if (pass.program) {
                                            const existingShaders = instance.shaders[pass.program];
                                            const hasInlineShaders = !!(pass.programSpec && (pass.programSpec.fragment || pass.programSpec.vertex)) ||
                                                !!(existingShaders && (existingShaders.fragment || existingShaders.vertex || existingShaders.glsl || existingShaders.wgsl));
                                            try {
                                                if (!hasInlineShaders) {
                                                    const glslRes = await fetch(`${dir.path}/${effectName}/glsl/${pass.program}.glsl`);
                                                    if (glslRes.ok) {
                                                        const shaderBucket = instance.shaders[pass.program] ?? (instance.shaders[pass.program] = {});
                                                        shaderBucket.glsl = await glslRes.text();
                                                    }
                                                }
                                            } catch (e) {
                                                console.warn(`Failed to load shaders for ${pass.program}`, e);
                                            }
                                        }
                                    }
                                }

                                effects.push({
                                    namespace: dir.namespace,
                                    name: effectName,
                                    instance: instance
                                });

                                // Register effect
                                registerEffect(instance.func, instance);
                                registerEffect(`${dir.namespace}.${instance.func}`, instance);

                                // Register as operator
                                if (instance.func) {
                                    const args = Object.entries(instance.globals || {}).map(([key, spec]) => ({
                                        name: key,
                                        type: spec.type === 'vec4' ? 'color' : spec.type,
                                        default: spec.default,
                                        enum: spec.enum,
                                        enumPath: spec.enumPath,
                                        min: spec.min,
                                        max: spec.max,
                                        uniform: spec.uniform
                                    }));
                                    
                                    const opSpec = {
                                        name: instance.func,
                                        args: args
                                    };
                                    registerOp(instance.func, opSpec);
                                    registerOp(`${dir.namespace}.${instance.func}`, opSpec);
                                }
                            }
                        } catch (err) {
                            console.warn(`Failed to load effect ${dir.namespace}/${effectName}:`, err);
                        }
                    }
                } catch (err) {
                    console.warn(`Failed to load effects from ${dir.path}:`, err);
                }
            }

            return effects;
        }

        // Fetch list of effects in a directory
        async function fetchEffectList(basePath) {
            const lists = {
                '../../shaders/effects/basics': [
                    'add', 'alpha', 'blend', 'blue', 'brightness', 'color', 'colorparty', 'contrast', 'diff', 'gradient', 'green', 'hue', 'invert', 'kaleid', 'layer', 'luma', 'mask', 'modulate', 'modulateHue', 'modulateKaleid', 'modulatePixelate', 'modulateRepeat', 'modulateRepeatX', 'modulateRepeatY', 'modulateRotate', 'modulateScale', 'modulateScrollX', 'modulateScrollY', 'mult', 'noise', 'osc', 'pixelate', 'posterize', 'prev', 'red', 'repeat', 'repeatX', 'repeatY', 'rot', 'saturate', 'scale', 'scroll', 'scrollX', 'scrollY', 'shape', 'shift', 'solid', 'src', 'sub', 'sum', 'thresh', 'translate', 'voronoi'
                ],
                '../../shaders/effects/nd': [
                    'atmosphere', 'background', 'bit-effects', 'cell-noise', 'cell-refract', 'cellular-automata', 'cellular-automata-mn', 'coalesce', 'color-lab', 'composite', 'demo-synth', 'depth-of-field', 'displace-mixer', 'effects', 'erosion-worms', 'feedback-mixer', 'feedback-post', 'feedback-synth', 'final', 'fractal', 'glitch', 'kaleido', 'lens-distortion', 'media-input', 'media-mixer', 'media-post', 'noise', 'noise-3d', 'palette', 'pattern', 'physarum', 'reaction-diffusion', 'refract', 'shape-mixer', 'shapes', 'shapes-3d', 'splat', 'text', 'tunnel', 'warp', 'wgsl-mixer-demo', 'wgsl-post-demo', 'worms'
                ],
                '../../shaders/effects/nm': [
                    'aberration', 'adjust_brightness', 'adjust_contrast', 'adjust_hue', 'adjust_saturation', 'bloom', 'blur', 'clouds', 'color_map', 'conv_feedback', 'convolve', 'crt', 'degauss', 'density_map', 'derivative', 'dla', 'erosion_worms', 'false_color', 'fibers', 'frame', 'fxaa', 'glowing_edges', 'glyph_map', 'grain', 'grime', 'jpeg_decimate', 'kaleido', 'lens_distortion', 'lens_warp', 'light_leak', 'lowpoly', 'nebula', 'normal_map', 'normalize', 'on_screen_display', 'outline', 'palette', 'pixel_sort', 'posterize', 'refract', 'reindex', 'reverb', 'ridge', 'ripple', 'rotate', 'scanline_error', 'scratches', 'shadow', 'simple_frame', 'sine', 'sketch', 'snow', 'sobel', 'spatter', 'spooky_ticker', 'stray_hair', 'texture', 'tint', 'value_refract', 'vaseline', 'vhs', 'vignette', 'voronoi', 'vortex', 'warp', 'wobble', 'wormhole', 'worms'
                ]
            };

            return lists[basePath] || [];
        }

        // Initialize starter ops
        function initStarterOps(effects) {
            const starterNames = effects
                .filter(e => isStarterEffect(e))
                .map(e => e.instance.func || e.name)
                .filter(name => name);

            if (starterNames.length > 0) {
                registerStarterOps(starterNames);
            }
        }

        // Populate effect selector
        function populateEffectSelector(effects) {
            effectSelect.innerHTML = '';
            
            const grouped = {};
            effects.forEach(effect => {
                if (!grouped[effect.namespace]) {
                    grouped[effect.namespace] = [];
                }
                grouped[effect.namespace].push(effect);
            });

            const sortedNamespaces = Object.keys(grouped).sort((a, b) => {
                if (a === 'basics') return -1;
                if (b === 'basics') return 1;
                return a.localeCompare(b);
            });

            sortedNamespaces.forEach(namespace => {
                const effectList = grouped[namespace];
                const optgroup = document.createElement('optgroup');
                optgroup.label = namespace;
                
                effectList.sort((a, b) => a.name.localeCompare(b.name)).forEach(effect => {
                    const option = document.createElement('option');
                    option.value = `${namespace}/${effect.name}`;
                    option.textContent = effect.name;
                    optgroup.appendChild(option);
                });
                
                effectSelect.appendChild(optgroup);
            });

            // Select 'noise' effect by default
            for (let i = 0; i < effectSelect.options.length; i++) {
                if (effectSelect.options[i].value === 'basics/noise') {
                    effectSelect.selectedIndex = i;
                    break;
                }
            }
        }

        // Create parameter controls
        function createParameterControls(effect) {
            parametersEl.innerHTML = '';
            parameterValues = {};

            if (!effect.instance.globals) {
                return;
            }

            Object.entries(effect.instance.globals).forEach(([key, spec]) => {
                if (spec.ui && spec.ui.control === false) return;

                const controlGroup = document.createElement('div');
                controlGroup.className = 'control-group';

                const label = document.createElement('label');
                label.textContent = spec.ui?.label || key;
                controlGroup.appendChild(label);

                const value = cloneParamValue(spec.default);
                parameterValues[key] = value;

                if (spec.type === 'boolean') {
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = value;
                    checkbox.addEventListener('change', (e) => {
                        parameterValues[key] = e.target.checked;
                        applyParameterValues();
                    });
                    controlGroup.appendChild(checkbox);
                } else if (spec.type === 'surface') {
                    const select = document.createElement('select');
                    const surfaces = spec.options?.surfaces || ['o0', 'o1', 'o2', 'o3', 'o4', 'o5', 'o6', 'o7'];

                    surfaces.forEach(surfaceName => {
                        const option = document.createElement('option');
                        option.value = surfaceName;
                        option.textContent = surfaceName;
                        option.selected = surfaceName === value;
                        select.appendChild(option);
                    });

                    select.addEventListener('change', async (e) => {
                        parameterValues[key] = e.target.value;
                        await rebuildPipeline({ silent: true });
                    });

                    controlGroup.appendChild(select);
                    const normalized = typeof value === 'string' && surfaces.includes(value) ? value : surfaces[0];
                    select.value = normalized;
                    parameterValues[key] = normalized;
                } else if (spec.choices) {
                    const select = document.createElement('select');
                    Object.entries(spec.choices).forEach(([name, val]) => {
                        if (name.endsWith(':')) return; // Skip category headers
                        const option = document.createElement('option');
                        option.value = val;
                        option.textContent = name;
                        option.selected = val === value;
                        select.appendChild(option);
                    });
                    select.addEventListener('change', (e) => {
                        parameterValues[key] = spec.type === 'int' ? parseInt(e.target.value) : parseFloat(e.target.value);
                        applyParameterValues();
                    });
                    controlGroup.appendChild(select);
                } else if (spec.type === 'member') {
                    // Resolve enum path
                    let enumPath = spec.enum || spec.enumPath;
                    if (!enumPath && typeof spec.default === 'string') {
                        // Infer from default value like "noise.color.rgb" -> "noise.color"
                        const parts = spec.default.split('.');
                        if (parts.length > 1) {
                            enumPath = parts.slice(0, -1).join('.');
                        }
                    }

                    if (enumPath) {
                        // Traverse enums
                        const parts = enumPath.split('.');
                        let node = enums;
                        for (const part of parts) {
                            if (node && node[part]) {
                                node = node[part];
                            } else {
                                node = null;
                                break;
                            }
                        }

                        if (node) {
                            const select = document.createElement('select');
                            // Iterate over keys
                            Object.keys(node).forEach(key => {
                                const option = document.createElement('option');
                                const fullPath = `${enumPath}.${key}`;
                                option.value = fullPath;
                                option.textContent = key;
                                option.selected = fullPath === value;
                                select.appendChild(option);
                            });
                            
                            select.addEventListener('change', (e) => {
                                parameterValues[key] = e.target.value;
                                applyParameterValues();
                            });
                            controlGroup.appendChild(select);
                        }
                    }
                } else if (spec.type === 'float' || spec.type === 'int') {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'slider-wrapper';

                    const slider = document.createElement('input');
                    slider.type = 'range';
                    slider.min = spec.min !== undefined ? spec.min : 0;
                    slider.max = spec.max !== undefined ? spec.max : 100;
                    slider.step = spec.step !== undefined ? spec.step : (spec.type === 'int' ? 1 : 0.01);
                    slider.value = value !== null ? value : slider.min;

                    const numberInput = document.createElement('input');
                    numberInput.type = 'number';
                    numberInput.min = slider.min;
                    numberInput.max = slider.max;
                    numberInput.step = slider.step;
                    numberInput.value = value !== null ? value : slider.min;

                    const updateValue = (val) => {
                        const numVal = spec.type === 'int' ? parseInt(val) : parseFloat(val);
                        slider.value = numVal;
                        numberInput.value = numVal;
                        parameterValues[key] = numVal;
                        applyParameterValues();
                    };

                    slider.addEventListener('input', (e) => updateValue(e.target.value));
                    numberInput.addEventListener('input', (e) => updateValue(e.target.value));

                    wrapper.appendChild(slider);
                    wrapper.appendChild(numberInput);
                    controlGroup.appendChild(wrapper);
                } else if (spec.type === 'vec4') {
                    const colorInput = document.createElement('input');
                    colorInput.type = 'color';
                    
                    // Convert [r,g,b,a] to #RRGGBB for the input
                    const toHex = (n) => Math.round(n * 255).toString(16).padStart(2, '0');
                    const r = toHex(value[0]);
                    const g = toHex(value[1]);
                    const b = toHex(value[2]);
                    colorInput.value = `#${r}${g}${b}`;

                    colorInput.addEventListener('input', (e) => {
                        const hex = e.target.value;
                        const r = parseInt(hex.slice(1, 3), 16) / 255;
                        const g = parseInt(hex.slice(3, 5), 16) / 255;
                        const b = parseInt(hex.slice(5, 7), 16) / 255;
                        // Preserve original alpha
                        const a = Array.isArray(parameterValues[key]) ? parameterValues[key][3] : 1;
                        parameterValues[key] = [r, g, b, a];
                        applyParameterValues();
                    });
                    controlGroup.appendChild(colorInput);
                } else if (spec.type === 'button') {
                    const button = document.createElement('button');
                    button.textContent = spec.ui?.label || key;
                    button.style.width = '100%';
                    button.style.padding = '8px';
                    button.style.background = '#333';
                    button.style.color = '#fff';
                    button.style.border = '1px solid #444';
                    button.style.cursor = 'pointer';
                    
                    button.addEventListener('mousedown', () => {
                        parameterValues[key] = true;
                        applyParameterValues({ silent: true });
                    });
                    
                    button.addEventListener('mouseup', () => {
                        parameterValues[key] = false;
                        applyParameterValues({ silent: true });
                    });
                    
                    button.addEventListener('mouseleave', () => {
                        if (parameterValues[key]) {
                            parameterValues[key] = false;
                            applyParameterValues({ silent: true });
                        }
                    });
                    
                    controlGroup.appendChild(button);
                }

                parametersEl.appendChild(controlGroup);
            });
        }

        // Helper to format values for DSL
        function formatValue(value, type) {
            if (type === 'boolean' || type === 'button') {
                return value ? 'true' : 'false';
            }
            if (type === 'surface') {
                if (typeof value !== 'string' || value.length === 0) {
                    return 'src(o0)';
                }
                if (value.includes('(')) {
                    return value;
                }
                return `src(${value})`;
            }
            if (type === 'member') {
                return value; // e.g. "noise.color.rgb"
            }
            if (type === 'vec4' && Array.isArray(value)) {
                const toHex = (n) => {
                    const hex = Math.round(n * 255).toString(16).padStart(2, '0');
                    return hex;
                };
                return `#${toHex(value[0])}${toHex(value[1])}${toHex(value[2])}${toHex(value[3])}`;
            }
            if (type === 'vec3' && Array.isArray(value)) {
                return `vec3(${value.join(', ')})`;
            }
            if (type === 'vec2' && Array.isArray(value)) {
                return `vec2(${value.join(', ')})`;
            }
            if (type === 'palette' || type === 'string' || type === 'text') {
                return `"${value}"`;
            }
            // float, int
            return value;
        }

        // Helper to check if effect is starter
        function isStarterEffect(effect) {
            const firstPass = effect.instance.passes?.[0];
            if (!firstPass || !firstPass.inputs) return true;
            
            const inputs = Object.values(firstPass.inputs);
            // Check if any input maps to a pipeline input (usually 'inputColor' or similar)
            const pipelineInputs = [
                'inputTex', 'src',
                'o0', 'o1', 'o2', 'o3', 'o4', 'o5', 'o6', 'o7'
            ];
            const hasPipelineInput = inputs.some(val => pipelineInputs.includes(val));
            
            return !hasPipelineInput;
        }

        // Select and load an effect
        async function selectEffect(effectPath, allEffects) {
            const [namespace, name] = effectPath.split('/');
            
            const effect = allEffects.find(e => e.namespace === namespace && e.name === name);
            
            if (!effect) {
                showStatus(`effect ${namespace}/${name} not found`, 'error');
                return;
            }

            currentEffect = effect;
            createParameterControls(currentEffect);
            showStatus(`selected ${namespace}/${name}`, 'success');
            await rebuildPipeline();
        }

        // Backend selector
        document.querySelectorAll('input[name="backend"]').forEach(radio => {
            radio.addEventListener('change', async (e) => {
                currentBackend = e.target.value;
                showStatus(`switched to ${currentBackend}`, 'success');
                await rebuildPipeline({ silent: true });
            });
        });

        // Effect selector
        let allLoadedEffects = [];
        effectSelect.addEventListener('change', async (e) => {
            await selectEffect(e.target.value, allLoadedEffects);
        });

        // Get effect from URL query parameter
        function getEffectFromURL() {
            const params = new URLSearchParams(window.location.search);
            const effectParam = params.get('effect');
            
            if (!effectParam) return null;
            
            // Convert from "namespace.effectName" to "namespace/effectName"
            const parts = effectParam.split('.');
            if (parts.length === 2) {
                return `${parts[0]}/${parts[1]}`;
            }
            
            return null;
        }

        // Initialize the demo
        async function init() {
            try {
                enums = await mergeIntoEnums(stdEnums);
                const effects = await loadEffects();
                allLoadedEffects = effects;
                initStarterOps(effects);
                populateEffectSelector(effects);
                
                loadingEl.style.display = 'none';
                appEl.style.display = 'grid';

                // Check for effect in URL query parameter
                const urlEffect = getEffectFromURL();
                let selectedEffect = null;

                if (urlEffect) {
                    // Verify the effect exists
                    const [namespace, name] = urlEffect.split('/');
                    const effect = effects.find(e => e.namespace === namespace && e.name === name);
                    
                    if (effect) {
                        selectedEffect = urlEffect;
                        // Update the select element to match
                        for (let i = 0; i < effectSelect.options.length; i++) {
                            if (effectSelect.options[i].value === urlEffect) {
                                effectSelect.selectedIndex = i;
                                break;
                            }
                        }
                    } else {
                        console.warn(`Effect "${urlEffect}" from URL not found`);
                    }
                }

                // Select effect (from URL or default)
                if (!selectedEffect && effectSelect.options.length > 0) {
                    selectedEffect = effectSelect.value;
                }

                if (selectedEffect) {
                    await selectEffect(selectedEffect, effects);
                }
                
                showStatus('demo loaded successfully', 'success');
            } catch (err) {
                console.error('Initialization failed:', err);
                loadingEl.textContent = `error: ${err.message}`;
                loadingEl.style.color = '#d44';
            }
        }

        init();
    </script>
</body>
</html>
